<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Retro-Modern Tetris ‚Äî Single File</title>
<style>
    :root{
        --bg:#071021;--panel:#0e1826;--neon:#39ffca;--accent:#7c5cff;--muted:#9fb0c8;
        --glass: rgba(255,255,255,0.03);
        --tile-size: 28px; /* base size, scales with viewport */
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: radial-gradient(1000px 600px at 10% 10%, rgba(60,100,140,0.06), transparent), var(--bg); color:#e6f0ff}
    .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:24px}
    .container{width:100%;max-width:960px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:16px;padding:18px;box-shadow:0 8px 40px rgba(3,10,20,0.6);display:grid;grid-template-columns: 1fr 220px;gap:16px}
    header{grid-column:1/-1;display:flex;align-items:center;justify-content:space-between}
    h1{font-size:20px;margin:0;color:var(--neon);text-shadow:0 0 8px rgba(57,255,202,0.08)}
    .sub{font-size:12px;color:var(--muted)}
    /* Game panel */
    .game-area{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));padding:14px;border-radius:12px;display:flex;flex-direction:column;align-items:center}
    .playfield{background:linear-gradient(180deg, rgba(0,0,0,0.08), rgba(255,255,255,0.02));padding:12px;border-radius:8px;box-shadow:inset 0 2px 10px rgba(0,0,0,0.6)}
    canvas#board{background: repeating-linear-gradient(0deg, rgba(255,255,255,0.015), rgba(255,255,255,0.015) 1px, transparent 1px, transparent 28px);display:block}
    /* Right side panel */
    .side{background:var(--panel);padding:12px;border-radius:12px;height:100%;display:flex;flex-direction:column;gap:12px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));padding:10px;border-radius:10px}
    .label{font-size:12px;color:var(--muted);margin-bottom:6px}
    .value{font-weight:700;color:#e6f0ff;font-size:18px}
    #nextCanvas{background:transparent;border-radius:6px}
    .controls{display:flex;gap:6px;flex-wrap:wrap}
    button.btn{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);padding:8px 10px;border-radius:8px;color:var(--muted);font-weight:600}
    .big{font-size:16px;padding:10px 14px}
    footer{grid-column:1/-1;margin-top:6px;text-align:center}
    /* Mobile controls */
    .touch-controls{display:none;position:fixed;left:50%;transform:translateX(-50%);bottom:18px;z-index:60;gap:8px}
    .touch-row{display:flex;gap:8px;align-items:center}
    .touch-btn{width:56px;height:56px;border-radius:12px;display:flex;align-items:center;justify-content:center;font-weight:700;background:var(--glass);border:1px solid rgba(255,255,255,0.04);backdrop-filter: blur(6px)}
    .touch-btn:active{transform:translateY(2px)}
    /* Neon link */
    .chat-link{display:inline-block;padding:10px 14px;border-radius:10px;background:linear-gradient(90deg, rgba(124,92,255,0.06), rgba(57,255,202,0.03));text-decoration:none;color:var(--neon);font-weight:700;box-shadow:0 0 16px rgba(57,255,202,0.06), 0 6px 20px rgba(7,16,33,0.6);border:1px solid rgba(57,255,202,0.07)}
    .chat-link span{filter:drop-shadow(0 0 6px rgba(57,255,202,0.12))}
    /* Responsive */
    @media(max-width:860px){.container{grid-template-columns:1fr;}
        .side{order:2}
        .touch-controls{display:flex}
        canvas#board{max-width:min(92vw,400px)}
    }
    /* small helpers */
    .muted{color:var(--muted);font-size:13px}
    .center{display:flex;align-items:center;justify-content:center}
</style>
</head>
<body>
<div class="wrap">
    <div class="container" role="application" aria-label="Tetris game">
        <header>
            <div>
                <h1>Retro‚ÄëModern Tetris</h1>
                <div class="sub">Classic gameplay ‚Ä¢ Responsive ‚Ä¢ Keyboard + touch ‚Ä¢ Synth sound effects</div>
            </div>
            <div class="sub">Tip: ‚Üë rotate ‚Ä¢ ‚Üê ‚Üí move ‚Ä¢ ‚Üì soft drop ‚Ä¢ Space hard drop</div>
        </header>

        <section class="game-area">
            <div class="playfield center">
                <canvas id="board" width="280" height="560" aria-label="Tetris board"></canvas>
            </div>
            <div style="margin-top:10px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:center">
                <button id="startBtn" class="btn big">Start</button>
                <button id="pauseBtn" class="btn big">Pause</button>
                <button id="resetBtn" class="btn big">Reset</button>
            </div>
            <div style="margin-top:12px;text-align:center;color:var(--muted);font-size:13px">Smooth animation, touch controls below on mobile</div>
        </section>

        <aside class="side">
            <div class="card">
                <div class="label">Next</div>
                <canvas id="nextCanvas" width="120" height="120"></canvas>
            </div>
            <div class="card">
                <div class="label">Score</div>
                <div id="score" class="value">0</div>
                <div class="muted">Lines: <span id="lines">0</span> ‚Ä¢ Level: <span id="level">1</span></div>
            </div>
            <div class="card">
                <div class="label">Controls</div>
                <div class="muted">Keyboard: ‚Üê ‚Üí ‚Üì ‚Üë ‚Ä¢ Space</div>
                <div style="margin-top:8px" class="muted">Mobile: on-screen buttons</div>
            </div>
            <div class="card center" style="flex-direction:column">
                <div class="label">Sound</div>
                <div style="display:flex;gap:8px"><button id="soundToggle" class="btn">Toggle Sound</button><button id="muteAll" class="btn">Mute</button></div>
            </div>
        </aside>

        <footer>
            <div style="margin-top:8px">
                <div style="margin-bottom:8px;font-weight:700;color:var(--muted)">Chat History Link</div>
                <a class="chat-link" href="https://chatgpt.com/share/68c8e1c1-b0e0-8013-8313-0ff8bfea22e6" target="_blank" rel="noopener noreferrer"> <span>üëâ View Chat History</span></a>
            </div>
        </footer>
    </div>

    <!-- Mobile touch controls -->
    <div class="touch-controls" id="touchControls" aria-hidden="false">
        <div class="touch-row">
            <div class="touch-btn" id="btnLeft">‚óÄ</div>
            <div class="touch-btn" id="btnDown">‚ñº</div>
            <div class="touch-btn" id="btnRight">‚ñ∂</div>
        </div>
        <div style="height:8px"></div>
        <div class="touch-row">
            <div class="touch-btn" id="btnRotate">‚§¥</div>
            <div class="touch-btn" id="btnDrop">‚§ì</div>
        </div>
    </div>
</div>

<script>
/*
 Single-file Tetris implementation
 - Clean structure
 - Uses canvas for rendering
 - Synthesizes audio with WebAudio API
 - Mobile touch controls and keyboard
 - Next preview, scoring, levels
*/

// ---- Game config ----
const COLS = 10;
const ROWS = 20;
let TILE = 28; // will scale on resize
const COLORS = {
    I:'#39ffca', J:'#7c5cff', L:'#ffb86b', O:'#ffd166', S:'#6ee7b7', T:'#c277ff', Z:'#ff6b6b'
};

const SHAPES = {
    I: [
        [[0,1],[1,1],[2,1],[3,1]],
        [[2,0],[2,1],[2,2],[2,3]],
        [[0,2],[1,2],[2,2],[3,2]],
        [[1,0],[1,1],[1,2],[1,3]]
    ],
    J: [
        [[0,0],[0,1],[1,1],[2,1]],
        [[1,0],[2,0],[1,1],[1,2]],
        [[0,1],[1,1],[2,1],[2,2]],
        [[1,0],[1,1],[0,2],[1,2]]
    ],
    L:[
        [[2,0],[0,1],[1,1],[2,1]],
        [[1,0],[1,1],[1,2],[2,2]],
        [[0,1],[1,1],[2,1],[0,2]],
        [[0,0],[1,0],[1,1],[1,2]]
    ],
    O:[
        [[1,0],[2,0],[1,1],[2,1]],
        [[1,0],[2,0],[1,1],[2,1]],
        [[1,0],[2,0],[1,1],[2,1]],
        [[1,0],[2,0],[1,1],[2,1]]
    ],
    S:[
        [[1,0],[2,0],[0,1],[1,1]],
        [[1,0],[1,1],[2,1],[2,2]],
        [[1,1],[2,1],[0,2],[1,2]],
        [[0,0],[0,1],[1,1],[1,2]]
    ],
    T:[
        [[1,0],[0,1],[1,1],[2,1]],
        [[1,0],[1,1],[2,1],[1,2]],
        [[0,1],[1,1],[2,1],[1,2]],
        [[1,0],[0,1],[1,1],[1,2]]
    ],
    Z:[
        [[0,0],[1,0],[1,1],[2,1]],
        [[2,0],[1,1],[2,1],[1,2]],
        [[0,1],[1,1],[1,2],[2,2]],
        [[1,0],[0,1],[1,1],[0,2]]
    ]
};

// game state
let board = createMatrix(COLS, ROWS);
let ctxBoard, ctxNext;
let canvasBoard = document.getElementById('board');
let nextCanvas = document.getElementById('nextCanvas');
let scoreEl = document.getElementById('score');
let linesEl = document.getElementById('lines');
let levelEl = document.getElementById('level');
let startBtn = document.getElementById('startBtn');
let pauseBtn = document.getElementById('pauseBtn');
let resetBtn = document.getElementById('resetBtn');
let soundToggle = document.getElementById('soundToggle');
let muteAllBtn = document.getElementById('muteAll');
let touchControls = document.getElementById('touchControls');

let gameInterval = null;
let dropCounter = 0;
let dropInterval = 1000; // ms, will change per level
let lastTime = 0;
let running = false;
let paused = false;
let score = 0, lines = 0, level = 1;

let current = null;
let nextPiece = null;

// Audio synth
let audioCtx = null;
let soundOn = true;

function ensureAudio(){
    if(!audioCtx){
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
}
function playBeep(type='blip', freq=440, dur=0.06, vol=0.08){
    if(!soundOn) return;
    ensureAudio();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
    o.stop(audioCtx.currentTime + dur + 0.02);
}
function playClear(){ playBeep('sine',880,0.08,0.14); }
function playMove(){ playBeep('square',220,0.04,0.06); }
function playRotate(){ playBeep('sawtooth',520,0.05,0.07); }
function playDrop(){ playBeep('triangle',160,0.02,0.06); }
function playGameOver(){ playBeep('sine',120,0.5,0.18); playBeep('sawtooth',60,0.5,0.08); }

// Utilities
function createMatrix(w,h){ const m = []; for(let y=0;y<h;y++){ m[y]=new Array(w).fill(null);} return m }
function randPiece(){ const keys = Object.keys(SHAPES); const k = keys[Math.floor(Math.random()*keys.length)]; return {type:k, rot:0, x:3, y:0}
}

// Resize and scale canvas
function resize(){
    const maxWidth = Math.min(window.innerWidth-120, 420);
    // tile size based on board canvas height
    const available = Math.min(maxWidth, Math.floor(window.innerHeight*0.6));
    TILE = Math.floor(available / ROWS * 1.02);
    canvasBoard.width = COLS * TILE;
    canvasBoard.height = ROWS * TILE;
    canvasBoard.style.width = canvasBoard.width + 'px';
    canvasBoard.style.height = canvasBoard.height + 'px';
    nextCanvas.width = 4 * TILE; nextCanvas.height = 4 * TILE;
    ctxBoard = canvasBoard.getContext('2d');
    ctxBoard.imageSmoothingEnabled = false;
    ctxNext = nextCanvas.getContext('2d'); ctxNext.imageSmoothingEnabled = false;
    render();
}
window.addEventListener('resize', resize);
resize();

// Drawing helpers
function drawCell(ctx,x,y,color,alpha=1){
    const pad=1; const bx = x*TILE + pad; const by = y*TILE + pad; const s = TILE - pad*2;
    ctx.save(); ctx.globalAlpha = alpha;
    // main rect
    ctx.fillStyle = color; ctx.fillRect(bx,by,s,s);
    // inner bevel
    ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth=1; ctx.strokeRect(bx+0.5,by+0.5,s-1,s-1);
    // subtle highlight
    ctx.fillStyle = 'rgba(255,255,255,0.03)'; ctx.fillRect(bx+2,by+2,s-4,s/3);
    // drop shadow
    ctx.restore();
}

function renderBoard(){
    ctxBoard.clearRect(0,0,canvasBoard.width,canvasBoard.height);
    // background grid subtle
    // draw static stack
    for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
            const cell = board[y][x];
            if(cell){ drawCell(ctxBoard,x,y,cell); }
            else{
                // empty tile faint border
                // ctxBoard.strokeStyle = 'rgba(255,255,255,0.01)'; ctxBoard.strokeRect(x*TILE+0.5, y*TILE+0.5, TILE-1, TILE-1);
            }
        }
    }
    // draw current falling piece
    if(current){ const shape = SHAPES[current.type][current.rot]; for(const p of shape){ const px = current.x + p[0]; const py = current.y + p[1]; if(py>=0) drawCell(ctxBoard,px,py,COLORS[current.type]); }}
}

function renderNext(){ ctxNext.clearRect(0,0,nextCanvas.width,nextCanvas.height); if(!nextPiece) return; const shape = SHAPES[nextPiece.type][0]; // draw centered
    const offsetX = 0; const offsetY = 0;
    for(const p of shape){ drawCell(ctxNext, p[0], p[1], COLORS[nextPiece.type]); }
}

function render(){ renderBoard(); renderNext(); }

// Collision and board ops
function collides(piece){ const shape = SHAPES[piece.type][piece.rot]; for(const p of shape){ const x = piece.x + p[0]; const y = piece.y + p[1]; if(x<0 || x>=COLS || y>=ROWS) return true; if(y>=0 && board[y][x]) return true; } return false }

function merge(piece){ const shape = SHAPES[piece.type][piece.rot]; for(const p of shape){ const x = piece.x + p[0]; const y = piece.y + p[1]; if(y>=0) board[y][x] = COLORS[piece.type]; } }

function clearLines(){ let cleared=0; for(let y=ROWS-1;y>=0;y--){ if(board[y].every(cell=>cell)){ board.splice(y,1); board.unshift(new Array(COLS).fill(null)); cleared++; y++; } }
    if(cleared>0){ lines += cleared; score += (cleared===4?800:cleared*100) * level; // classic-ish
        level = Math.floor(lines/10)+1; dropInterval = Math.max(80, 1000 - (level-1)*80);
        scoreEl.textContent = score; linesEl.textContent = lines; levelEl.textContent = level; playClear(); }
}

function spawn(){ current = nextPiece || randomPieceObj(); nextPiece = randomPieceObj(); current.x = 3; current.y = -1; current.rot = 0; if(collides(current)){ // game over
        running=false; clearInterval(gameInterval); playGameOver(); alert('Game Over ‚Äî Score: '+score); }
    render(); }

function randomPieceObj(){ const p = randPiece(); // ensure it has x,y
    p.x = 3; p.y = -1; p.rot = 0; return p }

// movement
function move(dir){ if(!current) return; current.x += dir; if(collides(current)){ current.x -= dir; } else { playMove(); render(); } }
function rotate(dir=1){ if(!current) return; const prev = current.rot; current.rot = (current.rot + dir + 4)%4; // kick attempts
    if(collides(current)){
        // simple wall kicks try left/right
        current.x += 1; if(!collides(current)) { playRotate(); render(); return; } current.x -=2; if(!collides(current)) { playRotate(); render(); return; } current.x +=1; current.rot = prev; return; }
    playRotate(); render(); }

function softDrop(){ if(!current) return; current.y +=1; if(collides(current)){ current.y -=1; lockPiece(); } else { score += 1; render(); playMove(); } }

function hardDrop(){ if(!current) return; while(!collides(current)){ current.y +=1 } current.y -=1; lockPiece(); score += 2; playDrop(); render(); }

function lockPiece(){ merge(current); clearLines(); spawn(); }

// Game loop
function start(){ if(running) return; // reset if not
    if(!audioCtx && soundOn) ensureAudio(); running=true; paused=false; score=0; lines=0; level=1; dropInterval=1000; board = createMatrix(COLS,ROWS); nextPiece = randomPieceObj(); spawn(); scoreEl.textContent = score; linesEl.textContent = lines; levelEl.textContent = level; lastTime = performance.now(); if(gameInterval) clearInterval(gameInterval); gameInterval = setInterval(step, 16); }

function pause(){ if(!running) return; paused = !paused; pauseBtn.textContent = paused? 'Resume':'Pause'; }

function reset(){ running=false; paused=false; if(gameInterval) clearInterval(gameInterval); board = createMatrix(COLS,ROWS); current=null; nextPiece=null; score=0; lines=0; level=1; scoreEl.textContent=0; linesEl.textContent=0; levelEl.textContent=1; render(); }

function step(){ if(paused || !running) return; const now = performance.now(); const delta = now - lastTime; if(delta > dropInterval){ lastTime = now; current.y +=1; if(collides(current)){ current.y -=1; lockPiece(); } render(); }
}

// Controls wiring
window.addEventListener('keydown', (e)=>{
    if(e.code==='ArrowLeft'){ e.preventDefault(); move(-1); }
    else if(e.code==='ArrowRight'){ e.preventDefault(); move(1); }
    else if(e.code==='ArrowUp'){ e.preventDefault(); rotate(1); }
    else if(e.code==='ArrowDown'){ e.preventDefault(); softDrop(); }
    else if(e.code==='Space'){ e.preventDefault(); hardDrop(); }
});

// Buttons
startBtn.addEventListener('click', ()=> start());
pauseBtn.addEventListener('click', ()=> pause());
resetBtn.addEventListener('click', ()=> reset());

// Touch buttons
const btnLeft = document.getElementById('btnLeft');
const btnRight = document.getElementById('btnRight');
const btnDown = document.getElementById('btnDown');
const btnRotate = document.getElementById('btnRotate');
const btnDrop = document.getElementById('btnDrop');

let holdInterval = null;
function bindTouch(btn, onPress, onRelease){
    let active=false;
    const startEv = (ev)=>{ ev.preventDefault(); active=true; onPress(); holdInterval = setInterval(onPress, 160); };
    const endEv = ()=>{ active=false; if(holdInterval) clearInterval(holdInterval); holdInterval=null; };
    btn.addEventListener('touchstart', startEv); btn.addEventListener('mousedown', startEv);
    btn.addEventListener('touchend', endEv); btn.addEventListener('mouseup', endEv); btn.addEventListener('mouseleave', endEv);
}
bindTouch(btnLeft, ()=> move(-1));
bindTouch(btnRight, ()=> move(1));
bindTouch(btnDown, ()=> softDrop());
bindTouch(btnRotate, ()=> rotate(1));
bindTouch(btnDrop, ()=> hardDrop());

// Sound toggles
soundToggle.addEventListener('click', ()=>{ soundOn = !soundOn; soundToggle.textContent = soundOn? 'Sound: On':'Sound: Off'; if(soundOn) ensureAudio(); });
muteAllBtn.addEventListener('click', ()=>{ soundOn=false; soundToggle.textContent='Sound: Off'; });

// Start on double-tap or click board
canvasBoard.addEventListener('dblclick', ()=>{ start(); });
canvasBoard.addEventListener('click', ()=>{ if(!audioCtx) ensureAudio(); });

// initial render
render();

// Accessibility: simple focus handlers present

// Prevent scrolling while touching controls
['touchstart','touchmove'].forEach(ev=> document.addEventListener(ev, (e)=>{
    if(e.target.closest('.touch-controls')) e.preventDefault(); }, {passive:false}));

</script>
</body>
</html>
