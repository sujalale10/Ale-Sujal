<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>GameBoy Retro Tetris — 90s Style</title>
<style>
  :root{
    --bg:#0a0a0a;
    --panel:#1c1c1c;
    --hud:#e9f0d9;
    --neon:#9ef08a;
    --muted:#9aa1a8;
    --tile: #cfd6c2;
    --border: #2b2b2b;
    --pixel-size: calc(min(6vmin,28px));
    --cols:10;
    --rows:20;
    --board-w: calc(var(--pixel-size) * var(--cols));
    --board-h: calc(var(--pixel-size) * var(--rows));
  }

  html,body{height:100%;margin:0;background:linear-gradient(180deg,#050505,#0b0b0b);font-family: "Press Start 2P", monospace, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;color:var(--hud);-webkit-font-smoothing:antialiased;}
  .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:20px;box-sizing:border-box}
  .app{
    display:grid;
    grid-template-columns: auto 300px;
    gap:20px;
    align-items:start;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:18px;border-radius:14px;border:2px solid rgba(255,255,255,0.02);
    box-shadow: 0 14px 40px rgba(0,0,0,0.7);
    max-width:1100px;width:100%;
  }

  /* Game board canvas container styled like GameBoy */
  .gb-frame{
    background:#dfe7d8;
    border-radius:10px;
    padding:18px;
    display:flex;flex-direction:column;align-items:center;
    box-shadow: inset 0 2px 0 rgba(255,255,255,0.6), 0 12px 30px rgba(0,0,0,0.6);
  }
  .screen{
    width:var(--board-w);height:var(--board-h);background:#f7f9ef;border:6px solid var(--border);
    box-shadow: inset 0 0 0 6px rgba(0,0,0,0.06);
    display:block;image-rendering:pixelated;
  }
  .controls-row{display:flex;gap:8px;margin-top:12px;align-items:center}
  button.btn{background:transparent;border:1px solid rgba(0,0,0,0.2);padding:8px 12px;border-radius:8px;color:var(--panel);cursor:pointer;font-size:12px;background:linear-gradient(180deg,#e6ebdf,#d0d7c5);box-shadow: 0 4px 10px rgba(0,0,0,0.2)}
  button.primary{background:linear-gradient(180deg,var(--neon),#88e16d);color:#07210a;border:0;font-weight:700}

  /* HUD */
  .hud{
    padding:14px 12px;border-radius:10px;background:linear-gradient(180deg,#0e0f0e,#131313);color:var(--hud);
    display:flex;flex-direction:column;gap:12px;height:var(--board-h);box-sizing:border-box;
  }
  .hud .slot{background:linear-gradient(180deg,#151615,#0f0f0f);padding:10px;border-radius:8px;border:2px solid rgba(255,255,255,0.02)}
  .title{font-size:12px;color:var(--muted);margin-bottom:6px}
  .value{font-size:20px;font-weight:700;letter-spacing:1px}

  .preview{width:120px;height:120px;background:#0b0b0b;border-radius:6px;display:grid;grid-template-rows:repeat(4,1fr);grid-template-columns:repeat(4,1fr);gap:4px;padding:6px;border:2px solid rgba(255,255,255,0.03)}
  .p-cell{background:transparent;border-radius:2px;border:1px solid rgba(255,255,255,0.03);box-sizing:border-box}

  /* Touch controls */
  .touch-controls{display:none;position:fixed;left:0;right:0;bottom:18px;padding:0 16px;pointer-events:none;justify-content:space-between;max-width:1000px;margin:0 auto}
  .touch-row{display:flex;gap:12px;pointer-events:auto}
  .touch-btn{width:56px;height:56px;border-radius:10px;background:linear-gradient(180deg,#151515,#0a0a0a);display:flex;align-items:center;justify-content:center;border:2px solid rgba(255,255,255,0.02);font-weight:700;color:var(--hud);touch-action: manipulation}

  /* neat neon link */
  .chatLink{margin-top:12px;padding:10px;border-radius:8px;text-align:center;background:linear-gradient(180deg,#091009,#071007);border:1px solid rgba(158,240,138,0.08)}
  .chatLink a{color:var(--neon);text-decoration:none;font-weight:700;display:inline-block;padding:6px 10px;border-radius:6px;box-shadow:0 6px 18px rgba(158,240,138,0.06);border:1px solid rgba(158,240,138,0.12)}

  /* grid layout responsiveness */
  @media (max-width:900px){
    .app{grid-template-columns: 1fr;gap:14px}
    .hud{height:auto}
    .touch-controls{display:flex}
  }

  /* pixel/retro small adjustments */
  .muted{color:var(--muted);font-size:12px}
  .note{font-size:11px;color:var(--muted);margin-top:6px}
</style>
</head>
<body>
  <div class="wrap">
    <div class="app" role="application" aria-label="Retro Tetris game">
      <div class="gb-frame" aria-hidden="false">
        <canvas id="screen" class="screen" width="0" height="0" aria-label="Tetris playfield"></canvas>

        <div class="controls-row" style="margin-top:10px;">
          <button class="btn" id="startBtn">Start</button>
          <button class="btn" id="pauseBtn">Pause</button>
          <button class="btn" id="muteBtn">Mute Music</button>
          <button class="btn" id="resetBtn">Reset</button>
        </div>
        <div class="note">Keyboard: ← → move • ↑ rotate • ↓ soft drop • Space hard drop • C hold</div>
      </div>

      <aside class="hud" aria-hidden="false">
        <div class="slot">
          <div class="title">SCORE</div>
          <div class="value" id="score">0</div>
        </div>

        <div class="slot">
          <div class="title">LEVEL</div>
          <div class="value" id="level">1</div>
        </div>

        <div class="slot">
          <div class="title">LINES</div>
          <div class="value" id="lines">0</div>
        </div>

        <div class="slot">
          <div class="title">NEXT</div>
          <div class="preview" id="preview"></div>
        </div>

        <div class="slot">
          <div class="title">HOLD</div>
          <div class="preview" id="holdPreview" style="height:60px"></div>
        </div>

        <div class="slot" style="flex:1;display:flex;flex-direction:column;justify-content:center;align-items:center;">
          <button class="primary" id="fullscreenBtn">Fullscreen</button>
          <div class="muted" style="margin-top:8px">90’s GameBoy inspired theme</div>
        </div>

        <div class="chatLink">
          <div class="muted">Chat History Link</div>
          <a href="https://chatgpt.com/share/68c8e1c1-b0e0-8013-8313-0ff8bfea22e6" target="_blank" rel="noopener noreferrer">View Chat History</a>
        </div>
      </aside>
    </div>
  </div>

  <!-- Mobile touch controls -->
  <div class="touch-controls" id="touch-controls" aria-hidden="true">
    <div class="touch-row" style="flex:1;justify-content:flex-start;">
      <div class="touch-btn" id="t-left">◀</div>
      <div class="touch-btn" id="t-rotate">⟳</div>
      <div class="touch-btn" id="t-right">▶</div>
    </div>
    <div class="touch-row" style="flex:1;justify-content:flex-end;">
      <div class="touch-btn" id="t-down">↓</div>
      <div class="touch-btn" id="t-drop">⤓</div>
    </div>
  </div>

<script>
/* -------------------------
   Game constants & data
--------------------------*/
const COLS = 10, ROWS = 20;
const TILE = Math.floor(Math.min(window.innerWidth, window.innerHeight) * 0.03) || 20; // will reflow below
const POINTS = {0:0,1:100,2:300,3:500,4:800};
const LINES_PER_LEVEL = 10;

/* Tetrominoes (matrix variants) - using 4x4 matrices for convenience */
const TETROMINOES = {
  I: [[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]]],
  J: [[[1,0,0],[1,1,1],[0,0,0]], [[0,1,1],[0,1,0],[0,1,0]], [[0,0,0],[1,1,1],[0,0,1]], [[0,1,0],[0,1,0],[1,1,0]]],
  L: [[[0,0,1],[1,1,1],[0,0,0]], [[0,1,0],[0,1,0],[0,1,1]], [[0,0,0],[1,1,1],[1,0,0]], [[1,1,0],[0,1,0],[0,1,0]]],
  O: [[[1,1],[1,1]]],
  S: [[[0,1,1],[1,1,0],[0,0,0]], [[0,1,0],[0,1,1],[0,0,1]]],
  T: [[[0,1,0],[1,1,1],[0,0,0]], [[0,1,0],[0,1,1],[0,1,0]], [[0,0,0],[1,1,1],[0,1,0]], [[0,1,0],[1,1,0],[0,1,0]]],
  Z: [[[1,1,0],[0,1,1],[0,0,0]], [[0,0,1],[0,1,1],[0,1,0]]]
};
const PIECES = Object.keys(TETROMINOES);

/* grayscale palette for GameBoy feel */
const PALETTE = {
  I: ['#e6f2e6','#cfe6cf'],
  J: ['#dfe6d9','#c6d6c2'],
  L: ['#dfe6d9','#c0d0b8'],
  O: ['#f2f7ee','#e0eedc'],
  S: ['#dfe6d9','#cde6d1'],
  T: ['#efecec','#e0e0dc'],
  Z: ['#f0efee','#e5e5e4']
};

/* -------------------------
   Canvas & rendering
--------------------------*/
const canvas = document.getElementById('screen');
const ctx = canvas.getContext('2d', { alpha:false });
const previewEl = document.getElementById('preview');
const holdPreview = document.getElementById('holdPreview');
let PIX = Math.max(12, Math.floor(Math.min(window.innerWidth, window.innerHeight) * 0.02));
function resizeCanvas(){
  // Fit to CSS declared size: match variable board pixel size for crisp "pixelated" look
  PIX = Math.max(12, Math.floor(Math.min(window.innerWidth, window.innerHeight) * 0.02));
  const boardW = COLS * PIX;
  const boardH = ROWS * PIX;
  canvas.width = boardW;
  canvas.height = boardH;
  canvas.style.width = boardW + 'px';
  canvas.style.height = boardH + 'px';
  // set imageRendering CSS for pixel look
  canvas.style.imageRendering = 'pixelated';
}
resizeCanvas();
window.addEventListener('resize', () => { resizeCanvas(); render(); renderPreview(); });

/* -------------------------
   Game state
--------------------------*/
let playfield = createPlayfield();
let current = null; // {type, rotation, x, y}
let nextPiece = null;
let holdPiece = null;
let canHold = true;
let score=0, lines=0, level=1;
let dropInterval = 1000, lastDrop=0;
let playing=false, paused=false;
let gameOverFlag=false;

/* -------------------------
   Audio: WebAudio 8-bit SFX & chiptune loop
--------------------------*/
let audioCtx = null;
let masterGain = null;
let musicGain = null;
let sfxGain = null;
let musicOn = true;

function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain(); masterGain.gain.value = 0.9; masterGain.connect(audioCtx.destination);
  musicGain = audioCtx.createGain(); musicGain.gain.value = 0.18; musicGain.connect(masterGain);
  sfxGain = audioCtx.createGain(); sfxGain.gain.value = 0.7; sfxGain.connect(masterGain);
  startMusic();
}

/* simple 8-bit blip generator */
function blip(freq=440, dur=0.07, type='square', gain=0.08){
  if(!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = gain;
  o.connect(g); g.connect(sfxGain);
  o.start();
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
  o.stop(audioCtx.currentTime + dur + 0.02);
}

/* chiptune-ish background loop (sequence) */
let musicTimer = null;
function startMusic(){
  if(!audioCtx) return;
  if(musicTimer) clearInterval(musicTimer);
  // simple loop using scheduled notes with setInterval (lightweight)
  const melody = [
    {f:880,t:0.14},{f:784,t:0.14},{f:660,t:0.28},{f:0,t:0.06},
    {f:660,t:0.14},{f:740,t:0.14},{f:880,t:0.28},{f:0,t:0.06}
  ];
  let idx=0;
  musicTimer = setInterval(()=>{
    const note = melody[idx];
    if(note.f>0){
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'square';
      o.frequency.value = note.f;
      g.gain.value = 0.06;
      o.connect(g); g.connect(musicGain);
      o.start();
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + note.t);
      o.stop(audioCtx.currentTime + note.t + 0.02);
    }
    idx = (idx + 1) % melody.length;
  }, 200);
}
function stopMusic(){ if(musicTimer) { clearInterval(musicTimer); musicTimer = null; } }
function toggleMusic(){
  if(!audioCtx) initAudio();
  musicOn = !musicOn;
  musicGain.gain.value = musicOn ? 0.18 : 0;
  document.getElementById('muteBtn').textContent = musicOn ? 'Mute Music' : 'Unmute Music';
}

/* -------------------------
   Helpers & utilities
--------------------------*/
function createPlayfield(){
  const a = [];
  for(let y=0;y<ROWS;y++) a.push(new Array(COLS).fill(null));
  return a;
}
function shuffle(a){
  for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; }
  return a;
}
let bag = [];
function randomPiece(){
  if(bag.length===0) bag = shuffle(PIECES.slice());
  return bag.pop();
}
function getMatrix(type, rot=0){
  const variants = TETROMINOES[type];
  return variants[rot % variants.length];
}

/* -------------------------
   Spawn & movement
--------------------------*/
function spawnPiece(type=null){
  const t = type || randomPiece();
  const m = getMatrix(t,0);
  const w = m[0].length;
  const x = Math.floor((COLS - w) / 2);
  const y = -m.length;
  return { type: t, rotation: 0, x, y };
}

function collide(piece, px=piece.x, py=piece.y, prot=piece.rotation){
  const m = getMatrix(piece.type, prot);
  for(let r=0;r<m.length;r++){
    for(let c=0;c<m[r].length;c++){
      if(m[r][c]){
        const x = px + c;
        const y = py + r;
        if(x<0 || x>=COLS || y>=ROWS) return true;
        if(y>=0 && playfield[y][x]) return true;
      }
    }
  }
  return false;
}

function move(dx,dy){
  if(!current || paused) return false;
  const nx = current.x + dx, ny = current.y + dy;
  if(!collide(current, nx, ny, current.rotation)){
    current.x = nx; current.y = ny;
    blip(900-(level*10), 0.04, 'square', 0.04);
    return true;
  }
  return false;
}

function rotate(dir=1){
  if(!current || paused) return false;
  const nrot = (current.rotation + dir + 1000) % 1000;
  const kicks = [0, -1, 1, -2, 2];
  for(let k of kicks){
    if(!collide(current, current.x + k, current.y, nrot)){
      current.rotation = nrot;
      current.x += k;
      blip(1200, 0.06, 'square', 0.06);
      return true;
    }
  }
  blip(200, 0.03, 'square', 0.02);
  return false;
}

function hardDrop(){
  if(!current || paused) return;
  const gy = getDropY();
  const dist = gy - current.y;
  current.y = gy;
  lockPiece();
  score += dist * 2;
  blip(600, 0.06, 'square', 0.08);
  renderHUD();
}

/* -------------------------
   Lock & clear lines with animation
--------------------------*/
function lockPiece(){
  const m = getMatrix(current.type, current.rotation);
  for(let r=0;r<m.length;r++){
    for(let c=0;c<m[r].length;c++){
      if(m[r][c]){
        const x = current.x + c;
        const y = current.y + r;
        if(y<0){ // game over
          gameOver();
          return;
        }
        playfield[y][x] = current.type;
      }
    }
  }
  // check clears
  const cleared = [];
  for(let y=0;y<ROWS;y++){
    if(playfield[y].every(cell => cell !== null)) cleared.push(y);
  }
  if(cleared.length){
    // animate glow by marking and delaying removal slightly
    animateLineClear(cleared);
    score += POINTS[cleared.length] * level;
    lines += cleared.length;
    const newLevel = Math.floor(lines / LINES_PER_LEVEL) + 1;
    if(newLevel !== level){
      level = newLevel;
      updateDropInterval();
      blip(1400, 0.12, 'square', 0.08);
    }
  }
  // next
  current = nextPiece ? spawnPiece(nextPiece) : spawnPiece();
  nextPiece = randomPiece();
  canHold = true;
  renderHUD();
}

function animateLineClear(rows){
  // fade out rows across 180ms and then remove
  const original = rows.slice();
  const start = performance.now();
  function tick(now){
    const t = (now - start) / 180;
    drawBoard(); drawGhost();
    // overlay glow
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = 1 - t;
    for(let y of original){
      ctx.fillStyle = 'rgba(220,240,200,0.16)';
      ctx.fillRect(0, y*PIX, COLS*PIX, PIX);
    }
    ctx.restore();
    if(t < 1) requestAnimationFrame(tick);
    else {
      // remove lines
      for(let i=0;i<original.length;i++){
        const y = original[i] - i; // shifting as we splice
        playfield.splice(y,1);
        playfield.unshift(new Array(COLS).fill(null));
      }
      blip(700, 0.14, 'square', 0.09);
      renderHUD();
    }
  }
  requestAnimationFrame(tick);
}

/* -------------------------
   Gravity and drop timing
--------------------------*/
function updateDropInterval(){
  const base = 1000;
  dropInterval = Math.max(60, Math.round(base * Math.pow(0.9, level-1)));
}

function getDropY(){
  if(!current) return 0;
  let y = current.y;
  while(!collide(current, current.x, y+1, current.rotation)) y++;
  return y;
}

/* -------------------------
   Hold logic
--------------------------*/
function holdCurrent(){
  if(!current || !canHold) return;
  if(!holdPiece){
    holdPiece = current.type;
    current = spawnPiece(nextPiece || randomPiece());
    nextPiece = randomPiece();
  } else {
    const tmp = holdPiece;
    holdPiece = current.type;
    current = spawnPiece(tmp);
  }
  canHold = false;
  blip(480, 0.06, 'square', 0.06);
  renderPreview();
}

/* -------------------------
   Rendering helpers
--------------------------*/
function clearCanvas(){
  ctx.fillStyle = '#f7f9ef';
  ctx.fillRect(0,0,canvas.width,canvas.height);
}
function drawCell(x,y,type,bright=false){
  const base = PALETTE[type] ? PALETTE[type][0] : '#ddd';
  const shade = PALETTE[type] ? PALETTE[type][1] : '#bbb';
  // draw outer pixel border to emulate GameBoy block
  ctx.fillStyle = bright ? shade : base;
  ctx.fillRect(x*PIX, y*PIX, PIX, PIX);
  ctx.strokeStyle = '#bfc9b2';
  ctx.lineWidth = Math.max(1, PIX*0.06);
  ctx.strokeRect(x*PIX + 0.5, y*PIX + 0.5, PIX-1, PIX-1);
}

/* draw board */
function drawBoard(){
  clearCanvas();
  // background subtle grid
  ctx.fillStyle = '#edf3e7';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  // cells
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const c = playfield[y][x];
      if(c) drawCell(x,y,c,false);
      else {
        // empty tile subtle border to emulate screen container grid
        ctx.fillStyle = '#f7f9ef';
        ctx.fillRect(x*PIX, y*PIX, PIX, PIX);
        ctx.strokeStyle = 'rgba(0,0,0,0.04)';
        ctx.lineWidth = 1;
        ctx.strokeRect(x*PIX + 0.5, y*PIX + 0.5, PIX-1, PIX-1);
      }
    }
  }
}

/* draw current piece */
function drawCurrent(){
  if(!current) return;
  const m = getMatrix(current.type, current.rotation);
  for(let r=0;r<m.length;r++){
    for(let c=0;c<m[r].length;c++){
      if(m[r][c]){
        const x = current.x + c;
        const y = current.y + r;
        if(y>=0) drawCell(x,y,current.type,true);
      }
    }
  }
}

/* draw ghost piece */
function drawGhost(){
  if(!current) return;
  const gy = getDropY();
  const m = getMatrix(current.type, current.rotation);
  ctx.save();
  ctx.globalAlpha = 0.18;
  for(let r=0;r<m.length;r++){
    for(let c=0;c<m[r].length;c++){
      if(m[r][c]){
        const x = current.x + c;
        const y = gy + r;
        if(y>=0) drawCell(x,y,current.type,false);
      }
    }
  }
  ctx.restore();
}

function render(){
  drawBoard();
  drawGhost();
  drawCurrent();
  // subtle grid overlay to mimic GameBoy pixel edges
  ctx.strokeStyle = 'rgba(0,0,0,0.035)';
  ctx.lineWidth = 1;
  for(let x=0;x<=COLS;x++){
    ctx.beginPath(); ctx.moveTo(x*PIX+0.5,0); ctx.lineTo(x*PIX+0.5,ROWS*PIX); ctx.stroke();
  }
  for(let y=0;y<=ROWS;y++){
    ctx.beginPath(); ctx.moveTo(0,y*PIX+0.5); ctx.lineTo(COLS*PIX,y*PIX+0.5); ctx.stroke();
  }
}

/* -------------------------
   Preview rendering (DOM small grid)
--------------------------*/
function clearPreview(el){
  el.innerHTML = '';
  for(let y=0;y<4;y++){
    for(let x=0;x<4;x++){
      const d = document.createElement('div');
      d.className = 'p-cell';
      d.style.width = Math.max(10, Math.floor(PIX*0.8)) + 'px';
      d.style.height = Math.max(10, Math.floor(PIX*0.8)) + 'px';
      el.appendChild(d);
    }
  }
}
function renderPreview(){
  clearPreview(previewEl);
  if(!nextPiece) return;
  const shape = getMatrix(nextPiece,0);
  const offsetX = Math.floor((4 - shape[0].length)/2);
  const offsetY = Math.floor((4 - shape.length)/2);
  for(let r=0;r<shape.length;r++){
    for(let c=0;c<shape[r].length;c++){
      if(shape[r][c]){
        const idx = (offsetY + r)*4 + (offsetX + c);
        const el = previewEl.children[idx];
        el.style.background = PALETTE[nextPiece][0];
        el.style.borderColor = '#bfc9b2';
      }
    }
  }
  // hold preview
  clearPreview(holdPreview);
  if(holdPiece){
    const shape2 = getMatrix(holdPiece,0);
    const ox = Math.floor((4 - shape2[0].length)/2);
    const oy = Math.floor((2 - shape2.length)/2);
    for(let r=0;r<shape2.length;r++){
      for(let c=0;c<shape2[r].length;c++){
        if(shape2[r][c]){
          const idx = (oy + r)*4 + (ox + c);
          const el = holdPreview.children[idx];
          if(el) { el.style.background = PALETTE[holdPiece][0]; el.style.borderColor = '#bfc9b2'; }
        }
      }
    }
  }
}

/* -------------------------
   HUD update
--------------------------*/
function renderHUD(){
  document.getElementById('score').textContent = score;
  document.getElementById('level').textContent = level;
  document.getElementById('lines').textContent = lines;
  renderPreview();
}

/* -------------------------
   Game lifecycle
--------------------------*/
function startGame(){
  initAudio();
  playfield = createPlayfield();
  bag = [];
  current = spawnPiece();
  nextPiece = randomPiece();
  holdPiece = null;
  canHold = true;
  score = 0; lines = 0; level = 1;
  updateDropInterval();
  playing = true; paused = false; gameOverFlag = false;
  lastDrop = performance.now();
  requestAnimationFrame(loop);
  renderHUD();
  blip(800,0.06,'square',0.06);
}
function pauseGame(){ paused = !paused; document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause'; blip(260,0.04,'square',0.04); }
function resetGame(){ playing=false; paused=false; stopMusic(); playfield = createPlayfield(); current = null; nextPiece = null; holdPiece=null; render(); renderHUD(); }
function gameOver(){
  playing=false; gameOverFlag=true; stopMusic();
  blip(120,0.3,'square',0.09);
  setTimeout(()=> alert('Game Over — Score: ' + score), 60);
}
function stopMusic(){ if(musicTimer) clearInterval(musicTimer); musicTimer=null; }

/* -------------------------
   Main loop
--------------------------*/
function loop(now){
  if(!playing) return;
  if(!audioCtx) initAudio();
  // gravity
  if(!paused){
    if(now - lastDrop > dropInterval){
      if(!move(0,1)){
        // can't move down -> lock
        lockPiece();
      }
      lastDrop = now;
    }
  }
  render();
  requestAnimationFrame(loop);
}

/* -------------------------
   Input handling: keyboard + touch
--------------------------*/
window.addEventListener('keydown', (e)=>{
  if(!playing) return;
  if(e.key === 'ArrowLeft'){ e.preventDefault(); move(-1,0); render(); }
  else if(e.key === 'ArrowRight'){ e.preventDefault(); move(1,0); render(); }
  else if(e.key === 'ArrowDown'){ e.preventDefault(); move(0,1); score+=1; render(); }
  else if(e.key === 'ArrowUp'){ e.preventDefault(); rotate(1); render(); }
  else if(e.code === 'Space'){ e.preventDefault(); hardDrop(); render(); }
  else if(e.key.toLowerCase() === 'c'){ e.preventDefault(); holdCurrent(); render(); }
  else if(e.key.toLowerCase() === 'p'){ e.preventDefault(); pauseGame(); }
});

/* touch helpers */
function makeTouch(id, handler, repeat=false){
  const el = document.getElementById(id);
  let timer = null;
  const start = (ev)=>{
    ev.preventDefault();
    handler();
    if(repeat){
      timer = setInterval(handler, 140);
    }
  };
  const end = ()=> { if(timer) clearInterval(timer); timer=null; };
  el.addEventListener('touchstart', start, {passive:false});
  el.addEventListener('mousedown', start);
  el.addEventListener('touchend', end);
  el.addEventListener('mouseup', end);
  el.addEventListener('mouseleave', end);
}

makeTouch('t-left', ()=>{ move(-1,0); render(); }, true);
makeTouch('t-right', ()=>{ move(1,0); render(); }, true);
makeTouch('t-down', ()=>{ move(0,1); score+=1; render(); }, true);
makeTouch('t-rotate', ()=>{ rotate(1); render(); }, false);
makeTouch('t-drop', ()=>{ hardDrop(); render(); }, false);

/* UI hooks */
document.getElementById('startBtn').addEventListener('click', ()=>{ startGame(); });
document.getElementById('pauseBtn').addEventListener('click', ()=>{ pauseGame(); });
document.getElementById('resetBtn').addEventListener('click', ()=>{ resetGame(); });
document.getElementById('muteBtn').addEventListener('click', ()=>{ toggleMusic(); });

document.getElementById('fullscreenBtn').addEventListener('click', ()=>{
  if(!document.fullscreenElement) document.documentElement.requestFullscreen().catch(()=>{});
  else document.exitFullscreen();
});

/* initialize visuals */
(function init(){
  resizeCanvas();
  render();
  renderPreview();
  // auto init audio on first user interaction
  const onInteract = ()=>{ initAudio(); window.removeEventListener('pointerdown', onInteract); };
  window.addEventListener('pointerdown', onInteract, {once:true});
})();

/* expose debug console actions */
window._retroTetris = { start:startGame, pause:pauseGame, reset:resetGame, toggleMusic:toggleMusic };

</script>
</body>
</html>
