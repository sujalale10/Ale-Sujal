<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>GameBoy Retro Tetris — Playable Version</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root{
            --bg:#0b0b0b;
            --panel:#0f0f0f;
            --accent:#cfcfcf;
            --muted:#9a9a9a;
            --glass: rgba(255,255,255,0.04);
            --crt: rgba(255,255,255,0.02);
            --shadow: rgba(0,0,0,0.8);
            --pixel-scale: 2;
        }
        html,body{height:100%;margin:0;background:linear-gradient(#060606,#0b0b0b);color:var(--accent);font-family:'Press Start 2P',monospace}
        .wrap{display:flex;flex-wrap:wrap;gap:18px;padding:18px;align-items:flex-start;justify-content:center;min-height:100vh}
        .panel{background:linear-gradient(180deg,var(--panel),#0b0b0b);padding:12px;border-radius:12px;box-shadow:0 8px 30px var(--shadow);position:relative}
        canvas{display:block;background:#2a2c28;image-rendering:pixelated;border-radius:6px;border: 4px solid #1a1a1a;}
        .hud{display:flex;flex-direction:column;gap:8px}
        .box{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:10px;border-radius:8px;min-width:160px}
        .controls{display:flex;gap:6px;flex-wrap:wrap}
        button, input[type=range], select{font-family:inherit;font-size:11px;background:#333;color:var(--accent);border:1px solid #444;border-radius:4px;padding:6px 8px;cursor:pointer;}
        button:hover{background:#444;}
        input[type=range]{padding:0;}
        .muted{color:var(--muted);font-size:11px}
        .crt{ position:absolute;left:0;top:0;right:0;bottom:0;border-radius:12px;pointer-events:none; background-image: linear-gradient(rgba(0,0,0,0.06) 1px, transparent 1px), linear-gradient(90deg, rgba(0,0,0,0.03) 1px, transparent 1px); background-size:100% 3px, 3px 100%; mix-blend-mode:overlay;opacity:0.6; }
        .overlay-vignette{position:absolute;inset:0;border-radius:12px;box-shadow:inset 0 30px 60px rgba(0,0,0,0.6);pointer-events:none}
        .small{font-size:11px}
        .kbd{display:inline-block;padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.03)}
        .modal-backdrop{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:50}
        .modal{background:var(--panel);padding:18px;border-radius:12px;min-width:320px;max-width:90%;box-shadow:0 8px 40px rgba(0,0,0,0.8)}
        .hidden{display:none}
        .touch-controls{display:grid; grid-template-columns: repeat(3, 1fr); gap:8px;margin-top:8px}
        .touch-controls button{padding:12px;border-radius:8px;border:none;background:#222;color:var(--accent);font-size:16px}
        .touch-controls .hard-drop{grid-column: 1 / -1;}
        label{display:flex;gap:8px;align-items:center; justify-content: space-between;}
        .next-grid, .hold-grid{display:grid;grid-template-columns:repeat(4,1fr);grid-template-rows:repeat(2,1fr);gap:1px;background:#111;padding:6px;border-radius:6px;width:80px;height:40px;margin-top:4px;}
        .piece-cell{width:100%;height:100%;background:#8b8b8b;border-radius:2px;}
        a.cta{display:inline-block;padding:6px 8px;border-radius:6px;background:#111;border:1px solid rgba(255,255,255,0.04);color:var(--accent);text-decoration:none;margin-top:6px}
    </style>
</head>
<body>
    <div class="wrap" id="app">
        <div class="panel" style="width:360px;">
            <div style="display:flex;gap:10px;align-items:flex-start">
                <canvas id="board" width="240" height="480" tabindex="0" aria-label="Tetris board"></canvas>
                <div class="hud">
                    <div class="box">
                        <div>Next</div>
                        <div id="next" class="next-grid"></div>
                    </div>
                    <div class="box">
                        <div>Hold</div>
                        <div id="hold" class="hold-grid"></div>
                    </div>
                </div>
            </div>
            <div style="margin-top:10px;display:flex;gap:8px;align-items:center;justify-content:space-between">
                <div class="small muted">Score: <span id="score">0</span></div>
                <div class="small muted">Level: <span id="level">0</span></div>
                <div class="small muted">Lines: <span id="lines">0</span></div>
            </div>
            <div style="display:flex;gap:8px;margin-top:10px;">
                <button id="btn-pause" class="small">Pause</button>
                <button id="btn-restart" class="small">Restart</button>
                <button id="btn-settings" class="small">Settings</button>
                <a class="cta" id="chat-link" href="https://chatgpt.com/share/68d3be5c-74fc-8005-bf2a-81798392ff08" target="_blank" rel="noopener">ChatGPT History</a>
            </div>
            <div class="crt"></div>
            <div class="overlay-vignette"></div>
        </div>
        <div style="display:flex;flex-direction:column;gap:12px;width:320px">
            <div class="panel box" aria-labelledby="settings-title">
                <div id="settings-title" style="font-size:12px">Settings</div>
                <div style="display:flex;flex-direction:column;gap:8px;margin-top:8px">
                    <label class="small"><input id="toggle-music" type="checkbox"> Music</label>
                    <label class="small"><input id="toggle-sound" type="checkbox" checked> Sound</label>
                    <label class="small">DAS <input id="das-range" type="range" min="50" max="300" value="170"> <span id="das-val">170</span>ms</label>
                    <label class="small">ARR <input id="arr-range" type="range" min="10" max="120" value="20"> <span id="arr-val">20</span>ms</label>
                    <label class="small">Lock Delay <input id="lock-range" type="range" min="200" max="1500" value="500"> <span id="lock-val">500</span>ms</label>
                    <div style="display:flex;gap:8px">
                        <button id="btn-keymap" class="small">Key Remap</button>
                        <button id="btn-export" class="small">Export Replay</button>
                    </div>
                </div>
            </div>
            <div class="panel box">
                <div style="font-size:12px">Controls</div>
                <div class="muted small" style="margin-top:6px">Default: Arrows, Z/Up to rotate, C to hold, Space to hard drop.</div>
                <div class="touch-controls" id="touch-controls">
                    <button data-action="left">◀</button>
                    <button data-action="rotate">⟳</button>
                    <button data-action="right">▶</button>
                    <button data-action="soft">↓</button>
                    <button data-action="hard" class="hard-drop">⤓</button>
                    <button data-action="hold">Hold</button>
                </div>
            </div>
            <div class="panel box small muted" role="status" aria-live="polite">
                Highscore: <span id="highscore">0</span><br>
                <a class="cta" id="share-link" href="#" target="_blank" style="display:none;">Share Replay</a>
            </div>
        </div>
    </div>
    <div class="modal-backdrop" id="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
        <div class="modal" id="modal" role="document">
            <h3 id="modal-title">Game Over</h3>
            <div id="modal-body"></div>
            <div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end">
                <button id="modal-restart">Restart</button>
                <button id="modal-share">Share</button>
                <button id="modal-close">Close</button>
            </div>
        </div>
    </div>
    <div class="modal-backdrop" id="keymodal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
        <div class="modal" id="keymodal">
            <h3>Remap Keys</h3>
            <form id="keymap-form">
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
                    <label>Left<input data-bind="left" class="keybind" value="ArrowLeft"></label>
                    <label>Right<input data-bind="right" class="keybind" value="ArrowRight"></label>
                    <label>Rotate CW<input data-bind="rotate" class="keybind" value="ArrowUp"></label>
                    <label>Soft Drop<input data-bind="soft" class="keybind" value="ArrowDown"></label>
                    <label>Hard Drop<input data-bind="hard" class="keybind" value=" "></label>
                    <label>Hold<input data-bind="hold" class="keybind" value="c"></label>
                </div>
                <div style="display:flex;gap:8px;margin-top:8px;justify-content:flex-end">
                    <button type="submit">Save</button>
                    <button type="button" id="keymap-cancel">Cancel</button>
                </div>
            </form>
        </div>
    </div>
    <script>
    /* Developer: modular single-file Tetris
    Sections:
    - Constants & Utilities
    - RNG & Bag
    - SRS tables & rotation logic
    - Game state & rules (spawn, lock, line clear, scoring)
    - Input system (keyboard remap, DAS/ARR, touch, gamepad)
    - Renderer (high-DPI scaling, pixelated, ghost piece)
    - Audio (WebAudio scheduling)
    - UI/Storage/Modals
    - Replay export/import
    */

    /* =========================== Constants & Utilities =========================== */
    const COLS = 10, ROWS = 40, VISIBLE_ROWS = 20;
    const CELL_SIZE = 24; // logical pixels before DPI scaling
    const PIECES = {
        I: { color: '#00f0f0', matrix: [[1,1,1,1]] },
        J: { color: '#0000f0', matrix: [[1,0,0],[1,1,1]] },
        L: { color: '#f0a000', matrix: [[0,0,1],[1,1,1]] },
        O: { color: '#f0f000', matrix: [[1,1],[1,1]] },
        S: { color: '#00f000', matrix: [[0,1,1],[1,1,0]] },
        T: { color: '#a000f0', matrix: [[0,1,0],[1,1,1]] },
        Z: { color: '#f00000', matrix: [[1,1,0],[0,1,1]] }
    };
    const SPAWN_X = 3, SPAWN_Y = 18; // In 40-row buffer, spawn at row 18
    const LOCAL = {
        KEYMAP: 'tetris_keymap_v2',
        SETTINGS: 'tetris_settings_v2',
        HIGHSCORE: 'tetris_highscore_v2'
    };
    const DEFAULT_KEYMAP = {
        left: 'ArrowLeft',
        right: 'ArrowRight',
        rotate: 'ArrowUp',
        soft: 'ArrowDown',
        hard: ' ',
        hold: 'c'
    };
    const DEFAULT_SETTINGS = { music: false, sound: true, das: 170, arr: 20, lock: 500 };
    const SCORE_TABLE = {
        line: [0, 100, 300, 500, 800],
        tspin: { mini: 100, normal: 400, mini_single: 200, single: 800, double: 1200, triple: 1600 },
        back2back: 1.5,
        softdrop: 1,
        harddrop: 2
    };

    /* =========================== RNG & 7-bag =========================== */
    class BagRNG {
        constructor(seed = null) {
            this.seed = seed || Math.floor(Math.random() * 2 ** 31);
            this.rng = this.mulberry32(this.seed);
            this.queue = [];
            this.refill();
            this.refill();
        }
        mulberry32(a) {
            return function() {
                a |= 0; a = a + 0x6D2B79F5 | 0;
                let t = Math.imul(a ^ a >>> 15, 1 | a);
                t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }
        refill() {
            const bag = Object.keys(PIECES);
            for (let i = bag.length - 1; i > 0; i--) {
                const j = Math.floor(this.rng() * (i + 1));
                [bag[i], bag[j]] = [bag[j], bag[i]];
            }
            this.queue.push(...bag);
        }
        next() {
            if (this.queue.length < 7) this.refill();
            return this.queue.shift();
        }
        peek(n = 5) { return this.queue.slice(0, n); }
    }

    /* =========================== SRS: Super Rotation System =========================== */
    const SRS_KICKS = {
        normal: {
            '0>1': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]], '1>0': [[0,0],[1,0],[1,-1],[0,2],[1,2]],
            '1>2': [[0,0],[1,0],[1,-1],[0,2],[1,2]],   '2>1': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
            '2>3': [[0,0],[1,0],[1,1],[0,-2],[1,-2]],   '3>2': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
            '3>0': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]], '0>3': [[0,0],[1,0],[1,1],[0,-2],[1,-2]]
        },
        I: {
            '0>1': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]], '1>0': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
            '1>2': [[0,0],[-1,0],[2,0],[-1,2],[2,-1]], '2>1': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
            '2>3': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]], '3>2': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
            '3>0': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]], '0>3': [[0,0],[-1,0],[2,0],[-1,2],[-2,-1]]
        }
    };
    function rotateMatrix(mat, dir) {
        const h = mat.length, w = mat[0].length;
        const res = Array.from({ length: w }, () => Array(h).fill(0));
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                if (dir === 1) res[x][h - 1 - y] = mat[y][x];
                else res[w - 1 - x][y] = mat[y][x];
            }
        }
        return res;
    }

    /* =========================== Game state & rules =========================== */
    class Game {
        constructor(renderer, input, audio) {
            this.renderer = renderer;
            this.input = input;
            this.audio = audio;
            this.reset();
            this.loadStorage();
        }
        loadStorage() {
            try {
                const s = JSON.parse(localStorage.getItem(LOCAL.SETTINGS)) || {};
                this.settings = { ...DEFAULT_SETTINGS, ...s };
                this.das = this.settings.das;
                this.arr = this.settings.arr;
                this.lockDelay = this.settings.lock;
                const k = JSON.parse(localStorage.getItem(LOCAL.KEYMAP)) || {};
                this.keymap = { ...DEFAULT_KEYMAP, ...k };
                updateUIFromSettings(this);
            } catch (e) {
                this.settings = { ...DEFAULT_SETTINGS };
                this.keymap = { ...DEFAULT_KEYMAP };
            }
        }
        reset() {
            this.grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            this.rng = new BagRNG();
            this.spawnPiece(true);
            this.hold = null;
            this.holdUsed = false;
            this.replay = [];
            this.gameOver = false;
            this.isPaused = false;
            this.score = 0;
            this.lines = 0;
            this.level = 0;
            this.b2b = 0;
            this.combo = -1;
            this.gravityMs = this.gravityForLevel(0);
            this.dropCounter = 0;
            this.lockTimer = null;
            this.lockMoves = 0;
            updateUIFromGame(this);
        }
        bindEvents() {
            this.input.on('move', dir => { if (!this.gameOver && !this.isPaused) this.attemptMove(dir === 'left' ? -1 : 1, 0); });
            this.input.on('rotate', dir => { if (!this.gameOver && !this.isPaused) this.attemptRotate(dir); });
            this.input.on('soft', () => { if (!this.gameOver && !this.isPaused) this.softDrop(); });
            this.input.on('hard', () => { if (!this.gameOver && !this.isPaused) this.hardDrop(); });
            this.input.on('hold', () => { if (!this.gameOver && !this.isPaused) this.holdPiece(); });
        }
        gravityForLevel(l) { return 1000 * Math.pow(0.8 - (l * 0.007), l); }
        spawnPiece(initial = false) {
            const type = this.rng.next();
            const piece = { type, matrix: PIECES[type].matrix, x: SPAWN_X, y: SPAWN_Y, rot: 0 };
            this.current = piece;
            this.holdUsed = false;
            if (this.collides(piece, 0, 0)) {
                this.onGameOver();
            }
            if (!initial) this.replay.push({ t: Date.now(), a: 'spawn', p: type });
            this.renderer.renderAll(this);
        }
        collides(piece, ox, oy, mat = piece.matrix) {
            for (let y = 0; y < mat.length; y++) {
                for (let x = 0; x < mat[0].length; x++) {
                    if (mat[y][x]) {
                        const gx = piece.x + x + ox;
                        const gy = piece.y + y + oy;
                        if (gx < 0 || gx >= COLS || gy >= ROWS || (gy >= 0 && this.grid[gy][gx])) return true;
                    }
                }
            }
            return false;
        }
        attemptMove(dx, dy) {
            if (!this.current) return;
            if (!this.collides(this.current, dx, dy)) {
                this.current.x += dx;
                this.current.y += dy;
                this.renderer.renderAll(this);
                this.resetLockTimerOnMove();
                this.replay.push({ t: Date.now(), a: 'move', d: dx });
                if (this.settings.sound) this.audio.playMove();
                return true;
            }
            return false;
        }
        attemptRotate(dir) {
            if (!this.current) return false;
            const from = this.current.rot;
            const to = (from + dir + 4) % 4;
            const kickTable = this.current.type === 'I' ? SRS_KICKS.I : SRS_KICKS.normal;
            const kicks = kickTable[`${from}>${to}`] || [[0, 0]];
            const rotated = rotateMatrix(this.current.matrix, dir);

            for (let i = 0; i < kicks.length; i++) {
                const [kx, ky] = kicks[i];
                if (!this.collides(this.current, kx, -ky, rotated)) {
                    this.current.matrix = rotated;
                    this.current.x += kx;
                    this.current.y -= ky;
                    this.current.rot = to;
                    this.lastMoveWasRotate = true;
                    this.lastKickIndex = i;
                    this.renderer.renderAll(this);
                    this.resetLockTimerOnMove();
                    this.replay.push({ t: Date.now(), a: 'rotate', d: dir });
                    if (this.settings.sound) this.audio.playRotate();
                    return true;
                }
            }
            return false;
        }
        softDrop() {
            if (this.attemptMove(0, 1)) {
                this.score += SCORE_TABLE.softdrop;
            } else {
                this.startLockTimer();
            }
            updateUIFromGame(this);
        }
        hardDrop() {
            if (!this.current) return;
            let drop = 0;
            while (!this.collides(this.current, 0, 1)) {
                this.current.y++;
                drop++;
            }
            this.score += drop * SCORE_TABLE.harddrop;
            this.replay.push({ t: Date.now(), a: 'hard', d: drop });
            if (this.settings.sound) this.audio.playHardDrop();
            this.lockPiece();
        }
        holdPiece() {
            if (this.holdUsed) return;
            this.holdUsed = true;
            if (this.settings.sound) this.audio.playHold();
            const currentType = this.current.type;
            if (!this.hold) {
                this.hold = currentType;
                this.spawnPiece();
            } else {
                const heldType = this.hold;
                this.hold = currentType;
                this.current = { type: heldType, matrix: PIECES[heldType].matrix, x: SPAWN_X, y: SPAWN_Y, rot: 0 };
                if (this.collides(this.current, 0, 0)) this.onGameOver();
            }
            this.resetLockTimer();
            this.renderer.renderAll(this);
            this.replay.push({ t: Date.now(), a: 'hold' });
        }
        startLockTimer() {
            if (this.lockTimer) return;
            this.lockTimer = setTimeout(() => {
                if (this.current && this.collides(this.current, 0, 1)) {
                    this.lockPiece();
                }
            }, this.lockDelay);
            this.lockMoves = 0;
        }
        resetLockTimer() {
            if (this.lockTimer) clearTimeout(this.lockTimer);
            this.lockTimer = null;
        }
        resetLockTimerOnMove() {
            if (this.current && this.collides(this.current, 0, 1)) {
                 if (this.lockMoves < 15) {
                    this.resetLockTimer();
                    this.startLockTimer();
                    this.lockMoves++;
                }
            } else {
                this.resetLockTimer();
            }
        }
        tick(delta) {
            if (this.isPaused || this.gameOver || !this.current) return;
            this.dropCounter += delta;
            if (this.dropCounter >= this.gravityMs) {
                this.dropCounter = 0;
                if (!this.collides(this.current, 0, 1)) {
                    this.current.y++;
                } else {
                    this.startLockTimer();
                }
            }
            this.renderer.renderAll(this);
        }
        lockPiece() {
            if (!this.current) return;
            this.resetLockTimer();
            const p = this.current;
            const tspinData = this.detectTSpin(p);

            for (let y = 0; y < p.matrix.length; y++) {
                for (let x = 0; x < p.matrix[0].length; x++) {
                    if (p.matrix[y][x]) {
                        const gx = p.x + x, gy = p.y + y;
                        if (gy >= 0) this.grid[gy][gx] = p.type;
                    }
                }
            }
            this.current = null;
            const cleared = this.clearLines();
            this.applyScoring(cleared, tspinData);
            this.lastMoveWasRotate = false;
            this.lastKickIndex = 0;
            this.spawnPiece();
        }
        detectTSpin(piece) {
            if (piece.type !== 'T' || !this.lastMoveWasRotate) return null;

            const [cx, cy] = [piece.x + 1, piece.y + 1];
            const corners = [
                this.grid[cy-1]?.[cx-1], this.grid[cy-1]?.[cx+1],
                this.grid[cy+1]?.[cx-1], this.grid[cy+1]?.[cx+1]
            ];
            const filledCorners = corners.filter(c => c).length;

            if (filledCorners >= 3) {
                const frontCorners = piece.rot === 0 ? [corners[0], corners[1]] :
                                     piece.rot === 1 ? [corners[1], corners[3]] :
                                     piece.rot === 2 ? [corners[3], corners[2]] :
                                                         [corners[2], corners[0]];
                const filledFront = frontCorners.filter(c => c).length;
                if (this.lastKickIndex === 4 || filledFront < 2) return 'mini';
                return 'normal';
            }
            return null;
        }
        clearLines() {
            const rowsToClear = [];
            for (let y = 0; y < ROWS; y++) {
                if (this.grid[y].every(c => c)) rowsToClear.push(y);
            }
            if (rowsToClear.length > 0) {
                if (this.settings.sound) this.audio.playLineClear(rowsToClear.length);
                for (const r of rowsToClear) {
                    this.grid.splice(r, 1);
                    this.grid.unshift(Array(COLS).fill(0));
                }
            }
            return rowsToClear.length;
        }
        applyScoring(cleared, tspin) {
            if (cleared === 0 && !tspin) { this.combo = -1; return; }

            let baseScore = 0;
            if (tspin) {
                if (cleared === 1) baseScore = SCORE_TABLE.tspin[tspin === 'mini' ? 'mini_single' : 'single'];
                else if (cleared === 2) baseScore = SCORE_TABLE.tspin.double;
                else if (cleared === 3) baseScore = SCORE_TABLE.tspin.triple;
                else baseScore = SCORE_TABLE.tspin[tspin];
            } else {
                baseScore = SCORE_TABLE.line[cleared];
            }

            if ((tspin && cleared > 0) || cleared === 4) {
                if (this.b2b > 0) baseScore *= SCORE_TABLE.back2back;
                this.b2b++;
            } else if (cleared > 0) {
                this.b2b = 0;
            }

            this.combo++;
            if (this.combo > 0) baseScore += 50 * this.combo;

            this.score += Math.floor(baseScore * (this.level + 1));
            this.lines += cleared;
            this.level = Math.floor(this.lines / 10);
            this.gravityMs = this.gravityForLevel(this.level);
            updateUIFromGame(this);
        }
        onGameOver() {
            this.gameOver = true;
            if (this.settings.music) this.audio.stopTheme();
            if (this.settings.sound) this.audio.playGameOver();
            const hs = Number(localStorage.getItem(LOCAL.HIGHSCORE) || 0);
            if (this.score > hs) localStorage.setItem(LOCAL.HIGHSCORE, String(this.score));
            openModalGameOver(this);
        }
    }

    /* =========================== Input (keyboard, touch, gamepad) =========================== */
    class Input {
        constructor(game) {
            this.game = game;
            this.listeners = {};
            this.pressed = {};
            this.dasTimers = { left: null, right: null };
            this.arrInterval = null;
            this.loadKeymap();
            this.bind();
        }
        on(evt, fn) { (this.listeners[evt] || (this.listeners[evt] = [])).push(fn); }
        emit(evt, ...args) { (this.listeners[evt] || []).forEach(f => f(...args)); }
        loadKeymap() {
            try {
                const k = JSON.parse(localStorage.getItem(LOCAL.KEYMAP) || '{}');
                this.keymap = { ...DEFAULT_KEYMAP, ...k };
            } catch (e) { this.keymap = { ...DEFAULT_KEYMAP }; }
        }
        bind() {
            window.addEventListener('keydown', e => {
                if (e.repeat) return;
                const key = e.key === ' ' ? ' ' : e.key;
                this.pressed[key] = true;
                this.handleKeyDown(key, e);
            });
            window.addEventListener('keyup', e => {
                const key = e.key === ' ' ? ' ' : e.key;
                delete this.pressed[key];
                this.handleKeyUp(key);
            });
            document.getElementById('touch-controls').addEventListener('click', e => {
                const action = e.target.closest('button')?.dataset.action;
                if (action) {
                    this.game.audio.init(); // Ensure audio is ready on touch
                    this.emit(action, 1);
                }
            });
        }
        handleKeyDown(k, e) {
            const keyMap = this.keymap;
            if (Object.values(keyMap).includes(k)) {
                e.preventDefault();
                this.game.audio.init(); // Ensure audio is ready on key press
            }

            if (k === keyMap.left) this.startDas('left');
            else if (k === keyMap.right) this.startDas('right');
            else if (k === keyMap.rotate) this.emit('rotate', 1);
            else if (k === keyMap.soft) this.emit('soft');
            else if (k === keyMap.hard) this.emit('hard');
            else if (k === keyMap.hold) this.emit('hold');
        }
        handleKeyUp(k) {
            if (k === this.keymap.left) this.stopDas('left');
            if (k === this.keymap.right) this.stopDas('right');
        }
        startDas(side) {
            this.stopDas(side);
            this.emit('move', side);
            this.dasTimers[side] = setTimeout(() => {
                if (this.arrInterval) clearInterval(this.arrInterval);
                this.arrInterval = setInterval(() => this.emit('move', side), this.game.arr);
            }, this.game.das);
        }
        stopDas(side) {
            if (this.dasTimers[side]) clearTimeout(this.dasTimers[side]);
            if (!this.pressed[this.keymap.left] && !this.pressed[this.keymap.right]) {
                if (this.arrInterval) clearInterval(this.arrInterval);
                this.arrInterval = null;
            }
        }
    }

    /* =========================== Renderer =========================== */
    class Renderer {
        constructor() {
            this.canvas = document.getElementById('board');
            this.ctx = this.canvas.getContext('2d');
            this.cell = CELL_SIZE;
            this.scaleForDPI();
            window.addEventListener('resize', () => this.scaleForDPI());
        }
        scaleForDPI() {
            const dpr = window.devicePixelRatio || 1;
            this.canvas.style.width = `${COLS * this.cell}px`;
            this.canvas.style.height = `${VISIBLE_ROWS * this.cell}px`;
            this.canvas.width = COLS * this.cell * dpr;
            this.canvas.height = VISIBLE_ROWS * this.cell * dpr;
            this.ctx.scale(dpr, dpr);
            this.ctx.imageSmoothingEnabled = false;
        }
        renderAll(game) {
            this.clear();
            this.drawGrid(game.grid);
            if (game.current) {
                this.drawGhost(game.current, game);
                this.drawPiece(game.current);
            }
            this.drawNext(game);
            this.drawHold(game);
        }
        clear() {
            this.ctx.fillStyle = '#1a1a1a';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }
        drawGrid(grid) {
            for (let y = 0; y < VISIBLE_ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const gridY = y + (ROWS - VISIBLE_ROWS);
                    const cellType = grid[gridY][x];
                    if (cellType) {
                        this.drawCell(x, y, PIECES[cellType].color);
                    } else {
                        this.ctx.fillStyle = 'rgba(0,0,0,0.2)';
                        this.ctx.fillRect(x * this.cell, y * this.cell, this.cell, this.cell);
                    }
                }
            }
        }
        drawCell(x, y, color) {
            const s = this.cell;
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x * s, y * s, s, s);
            this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
            this.ctx.fillRect(x * s, y * s, s, 2);
            this.ctx.fillStyle = 'rgba(0,0,0,0.2)';
            this.ctx.fillRect(x * s, (y + 1) * s - 2, s, 2);
        }
        drawPiece(piece) {
            if (!piece) return;
            const m = piece.matrix;
            for (let y = 0; y < m.length; y++) {
                for (let x = 0; x < m[0].length; x++) {
                    if (m[y][x]) {
                        const drawY = piece.y + y - (ROWS - VISIBLE_ROWS);
                        if (drawY >= 0) {
                            this.drawCell(piece.x + x, drawY, PIECES[piece.type].color);
                        }
                    }
                }
            }
        }
        drawGhost(piece, game) {
            let ghost = JSON.parse(JSON.stringify(piece));
            while (!game.collides(ghost, 0, 1)) {
                ghost.y++;
            }
            const m = ghost.matrix;
            for (let y = 0; y < m.length; y++) {
                for (let x = 0; x < m[0].length; x++) {
                    if (m[y][x]) {
                        const drawY = ghost.y + y - (ROWS - VISIBLE_ROWS);
                        if (drawY >= 0) {
                            this.ctx.fillStyle = 'rgba(255,255,255,0.15)';
                            this.ctx.fillRect((ghost.x + x) * this.cell, drawY * this.cell, this.cell, this.cell);
                        }
                    }
                }
            }
        }
        drawPreviewPiece(container, type) {
            container.innerHTML = '';
            if (!type) return;
            const piece = PIECES[type];
            const matrix = piece.matrix;
            container.style.gridTemplateRows = `repeat(${matrix.length}, 1fr)`;
            container.style.gridTemplateColumns = `repeat(${matrix[0].length}, 1fr)`;

            for (let y = 0; y < matrix.length; y++) {
                for (let x = 0; x < matrix[0].length; x++) {
                    const cell = document.createElement('div');
                    if (matrix[y][x]) {
                        cell.className = 'piece-cell';
                        cell.style.backgroundColor = piece.color;
                    }
                    container.appendChild(cell);
                }
            }
        }
        drawNext(game) { this.drawPreviewPiece(document.getElementById('next'), game.rng.peek(1)[0]); }
        drawHold(game) { this.drawPreviewPiece(document.getElementById('hold'), game.hold); }
    }

    /* =========================== Audio =========================== */
    class AudioEngine {
        constructor() {
            this.ctx = null;
            this.masterGain = null;
            this.musicGain = null;
            this.sfxGain = null;
            this.musicSource = null;
            this.noteTime = 0;
            this.currentNote = 0;
            this.timer = null;
        }

        init() {
            if (this.ctx) return;
            try {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.musicGain = this.ctx.createGain();
                this.sfxGain = this.ctx.createGain();

                this.masterGain.gain.value = 0.5;
                this.musicGain.gain.value = 0.2;
                this.sfxGain.gain.value = 0.8;

                this.musicGain.connect(this.masterGain);
                this.sfxGain.connect(this.masterGain);
                this.masterGain.connect(this.ctx.destination);
            } catch (e) { console.error("Web Audio API not supported."); }
        }

        // --- Sound Effects ---
        playSfx(freq, dur = 0.05, type = 'square', attack = 0.005, decay = 0.01) {
            if (!this.ctx) return;
            if (this.ctx.state === 'suspended') this.ctx.resume();

            const o = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            o.type = type;
            o.frequency.setValueAtTime(freq, this.ctx.currentTime);
            g.gain.setValueAtTime(0, this.ctx.currentTime);
            g.gain.linearRampToValueAtTime(1, this.ctx.currentTime + attack);
            g.gain.linearRampToValueAtTime(0, this.ctx.currentTime + dur - decay);
            o.connect(g);
            g.connect(this.sfxGain);
            o.start();
            o.stop(this.ctx.currentTime + dur);
        }

        playMove() { this.playSfx(120, 0.05, 'triangle'); }
        playRotate() { this.playSfx(300, 0.06, 'triangle'); }
        playHardDrop() { this.playSfx(80, 0.1, 'square'); }
        playHold() { this.playSfx(440, 0.1, 'sine'); }
        playLineClear(lines) {
            if (lines === 4) {
                 this.playSfx(880, 0.4, 'sine');
            } else {
                 this.playSfx(600, 0.2, 'square');
            }
        }
        playGameOver() {
             this.playSfx(220, 0.2, 'sawtooth');
             setTimeout(() => this.playSfx(165, 0.2, 'sawtooth'), 150);
             setTimeout(() => this.playSfx(110, 0.5, 'sawtooth'), 300);
        }

        // --- Music ---
        playTheme() {
            if (!this.ctx) this.init();
            if (this.timer || !this.ctx) return;
            if (this.ctx.state === 'suspended') this.ctx.resume();

            const tempo = 140;
            const eighthNoteTime = (60 / tempo) / 2;

            const NOTES = { E5: 659.25, B4: 493.88, C5: 523.25, D5: 587.33, A4: 440.00, G4S: 415.30 };
            const TUNE = [
                {n: NOTES.E5, d: 2}, {n: NOTES.B4, d: 1}, {n: NOTES.C5, d: 1}, {n: NOTES.D5, d: 2}, {n: NOTES.C5, d: 1}, {n: NOTES.B4, d: 1},
                {n: NOTES.A4, d: 2}, {n: NOTES.A4, d: 1}, {n: NOTES.C5, d: 1}, {n: NOTES.E5, d: 2}, {n: NOTES.D5, d: 1}, {n: NOTES.C5, d: 1},
                {n: NOTES.B4, d: 3}, {n: NOTES.C5, d: 1}, {n: NOTES.D5, d: 2}, {n: NOTES.E5, d: 2},
                {n: NOTES.C5, d: 2}, {n: NOTES.A4, d: 2}, {n: NOTES.A4, d: 2}, {d: 4},
                {n: NOTES.D5, d: 3}, {n: NOTES.G4S, d: 1}, {n: NOTES.B4, d: 2}, {n: NOTES.A4, d: 1}, {n: NOTES.G4S, d: 1},
                {n: NOTES.C5, d: 3}, {n: NOTES.E5, d: 1}, {n: NOTES.A4, d: 4},
                {n: NOTES.G4S, d: 4}, {d: 4}
            ];

            const scheduler = () => {
                const note = TUNE[this.currentNote];
                const dur = note.d * eighthNoteTime;

                if (note.n) {
                    const o = this.ctx.createOscillator();
                    o.type = 'square';
                    o.frequency.setValueAtTime(note.n, this.ctx.currentTime);
                    o.connect(this.musicGain);
                    o.start();
                    o.stop(this.ctx.currentTime + dur * 0.9);
                }

                this.currentNote = (this.currentNote + 1) % TUNE.length;
                this.timer = setTimeout(scheduler, dur * 1000);
            };
            scheduler();
        }

        stopTheme() {
            if (this.timer) {
                clearTimeout(this.timer);
                this.timer = null;
                this.currentNote = 0;
            }
        }
    }

    /* =========================== UI & storage helpers =========================== */
    function loadSettings() {
        try {
            const s = JSON.parse(localStorage.getItem(LOCAL.SETTINGS) || '{}');
            return { ...DEFAULT_SETTINGS, ...s };
        } catch (e) { return { ...DEFAULT_SETTINGS }; }
    }
    function saveSettings(s) {
        localStorage.setItem(LOCAL.SETTINGS, JSON.stringify(s));
    }
    function updateUIFromSettings(game) {
        const s = game.settings;
        document.getElementById('toggle-music').checked = s.music;
        document.getElementById('toggle-sound').checked = s.sound;
        document.getElementById('das-range').value = s.das;
        document.getElementById('das-val').textContent = s.das;
        document.getElementById('arr-range').value = s.arr;
        document.getElementById('arr-val').textContent = s.arr;
        document.getElementById('lock-range').value = s.lock;
        document.getElementById('lock-val').textContent = s.lock;
        const hs = Number(localStorage.getItem(LOCAL.HIGHSCORE) || 0);
        document.getElementById('highscore').textContent = hs;
    }
    function updateUIFromGame(game) {
        document.getElementById('score').textContent = game.score;
        document.getElementById('level').textContent = game.level;
        document.getElementById('lines').textContent = game.lines;
        const hs = Number(localStorage.getItem(LOCAL.HIGHSCORE) || 0);
        document.getElementById('highscore').textContent = Math.max(hs, game.score);
    }
    function openModalGameOver(game) {
        const md = document.getElementById('modal-backdrop');
        md.style.display = 'flex';
        md.setAttribute('aria-hidden', 'false');
        document.getElementById('modal-title').textContent = 'Game Over';
        document.getElementById('modal-body').innerHTML = `<p>Score: ${game.score}</p><p>Lines: ${game.lines}</p>`;
        document.getElementById('modal-restart').onclick = () => {
            md.style.display = 'none';
            md.setAttribute('aria-hidden', 'true');
            startNewGame();
        };
        document.getElementById('modal-close').onclick = () => {
            md.style.display = 'none';
            md.setAttribute('aria-hidden', 'true');
        };
        document.getElementById('modal-share').onclick = () => exportReplay(game);
    }

    /* =========================== Replay export =========================== */
    function exportReplay(game) {
        const data = { seed: game.rng.seed, replay: game.replay, score: game.score, lines: game.lines, level: game.level };
        const jsonString = JSON.stringify(data);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `tetris_replay_${Date.now()}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }

    /* =========================== Boot & main loop =========================== */
    const renderer = new Renderer();
    const audio = new AudioEngine();
    const game = new Game(renderer, null, audio);
    const input = new Input(game);
    game.input = input;
    game.bindEvents();
    game.loadStorage();

    // UI wiring
    document.getElementById('btn-pause').addEventListener('click', () => {
        game.isPaused = !game.isPaused;
        document.getElementById('btn-pause').textContent = game.isPaused ? 'Resume' : 'Pause';
    });
    document.getElementById('btn-restart').addEventListener('click', () => startNewGame());
    document.getElementById('btn-settings').addEventListener('click', () => {
        const modal = document.querySelector('.panel.box[aria-labelledby="settings-title"]');
        modal.style.display = modal.style.display === 'none' ? 'block' : 'none';
    });

    document.getElementById('toggle-music').addEventListener('change', e => {
        game.settings.music = e.target.checked;
        saveSettings(game.settings);
        if (e.target.checked) audio.playTheme();
        else audio.stopTheme();
    });
    document.getElementById('toggle-sound').addEventListener('change', e => {
        game.settings.sound = e.target.checked;
        saveSettings(game.settings);
    });

    ['das', 'arr', 'lock'].forEach(id => {
        const range = document.getElementById(`${id}-range`);
        range.addEventListener('input', e => {
            const val = Number(e.target.value);
            game.settings[id] = val;
            if (id === 'lock') game.lockDelay = val;
            else game[id] = val;
            document.getElementById(`${id}-val`).textContent = val;
            saveSettings(game.settings);
        });
    });

    document.getElementById('btn-keymap').addEventListener('click', () => {
        document.querySelectorAll('.keybind').forEach(inp => {
            inp.value = input.keymap[inp.dataset.bind] || '';
        });
        document.getElementById('keymodal-backdrop').style.display = 'flex';
    });
    document.getElementById('keymap-cancel').addEventListener('click', () => document.getElementById('keymodal-backdrop').style.display = 'none');
    document.getElementById('keymap-form').addEventListener('submit', e => {
        e.preventDefault();
        e.target.querySelectorAll('.keybind').forEach(el => {
            input.keymap[el.dataset.bind] = el.value;
        });
        localStorage.setItem(LOCAL.KEYMAP, JSON.stringify(input.keymap));
        document.getElementById('keymodal-backdrop').style.display = 'none';
    });
    document.getElementById('btn-export').addEventListener('click', () => exportReplay(game));

    function startNewGame() {
        game.reset();
        game.isPaused = false;
        document.getElementById('btn-pause').textContent = 'Pause';
        if (game.settings.music) {
            audio.stopTheme();
            audio.playTheme();
        }
        lastTime = 0;
    }

    let lastTime = 0;
    function loop(now) {
        if (!lastTime) lastTime = now;
        const dt = now - lastTime;
        lastTime = now;
        game.tick(dt);
        requestAnimationFrame(loop);
    }

    document.getElementById('board').focus();
    startNewGame();
    requestAnimationFrame(loop);
    </script>
</body>
</html>
