<!DOCTYPE HTML>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Modern Retro Tetris</title>
<style>
  :root{
    --bg:#0b1020;
    --panel:#0f1724;
    --accent:#6ee7b7;
    --muted:#94a3b8;
    --cell:#0b1220;
    --cell-border: rgba(255,255,255,0.04);
    --glass: rgba(255,255,255,0.03);
    --tile-size: min(9vmin, 28px);
    --board-w: calc(var(--tile-size) * 10);
    --board-h: calc(var(--tile-size) * 20);
    --radius: 12px;
  }

  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
  body{
    background: linear-gradient(180deg,#02040a 0%, var(--bg) 50%);
    color:#e6eef6;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:24px;
    box-sizing:border-box;
  }

  .container{
    display:grid;
    grid-template-columns: auto 1fr;
    gap:20px;
    align-items:start;
    width:100%;
    max-width:1100px;
  }

  .sidebar{
    width:320px;
    max-width:35vw;
    background:linear-gradient(180deg,var(--panel), rgba(12,20,32,0.8));
    border-radius:var(--radius);
    padding:18px;
    box-shadow: 0 8px 30px rgba(2,6,23,0.6);
    display:flex;
    flex-direction:column;
    gap:12px;
  }

  .brand{
    display:flex;align-items:center;gap:12px;
  }
  .logo{
    width:48px;height:48px;border-radius:10px;background:linear-gradient(45deg,var(--accent),#60a5fa);
    display:flex;align-items:center;justify-content:center;font-weight:700;color:#07202a;
    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    font-size:20px;
  }
  h1{font-size:18px;margin:0}
  p.sub{margin:0;color:var(--muted);font-size:13px}

  .stats{
    display:grid;grid-template-columns:repeat(2,1fr);gap:10px;margin-top:6px;
  }
  .stat{
    background:var(--glass);padding:10px;border-radius:10px;text-align:center;
  }
  .stat .value{font-weight:700;font-size:18px}
  .stat .label{font-size:12px;color:var(--muted)}

  .controls, .meta{
    display:flex;gap:8px;flex-wrap:wrap;
  }
  button.btn{
    background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:10px;color:inherit;
    cursor:pointer;font-size:13px;backdrop-filter: blur(6px);transition:transform .12s ease,opacity .12s ease;
  }
  button.btn:hover{transform:translateY(-3px)}
  button.primary{
    background:linear-gradient(90deg,var(--accent),#60a5fa);color:#042225;border:0;font-weight:700;
    box-shadow: 0 6px 18px rgba(96,165,250,0.12);
  }

  .game-area{
    background:transparent;display:flex;gap:18px;align-items:flex-start;justify-content:center;
  }

  .board-wrap{
    width:var(--board-w);height:var(--board-h);position:relative;
    border-radius:10px;padding:10px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.02), 0 10px 30px rgba(2,6,23,0.6);
  }

  .board{
    display:grid;
    grid-template-columns: repeat(10, var(--tile-size));
    grid-template-rows: repeat(20, var(--tile-size));
    gap:4px;
    width:calc(var(--tile-size)*10 + 9*4px);
    height:calc(var(--tile-size)*20 + 19*4px);
    background:linear-gradient(180deg,#061122 80%, #061225 100%);
    padding:6px;border-radius:8px;box-sizing:border-box;
  }

  .cell{
    width:var(--tile-size);height:var(--tile-size);border-radius:6px;box-sizing:border-box;
    background:var(--cell);display:flex;align-items:center;justify-content:center;
    border:1px solid var(--cell-border);transition:transform .1s linear, box-shadow .12s linear;
  }
  .cell.filled{
    transform: translateY(-2px);
    box-shadow: 0 6px 18px rgba(0,0,0,0.6), inset 0 -4px 10px rgba(0,0,0,0.35);
  }

  /* tile colors */
  .t-I{background:linear-gradient(180deg,#8ee7ff,#4cc9ff);color:#04202a;border:1px solid rgba(255,255,255,0.06)}
  .t-J{background:linear-gradient(180deg,#bdb7ff,#7f7cff)}
  .t-L{background:linear-gradient(180deg,#ffd6a5,#ffad60)}
  .t-O{background:linear-gradient(180deg,#fff3a1,#ffd54a);color:#2b2b00}
  .t-S{background:linear-gradient(180deg,#a7f3d0,#34d399)}
  .t-T{background:linear-gradient(180deg,#e9c0ff,#c084fc);color:#2b0036}
  .t-Z{background:linear-gradient(180deg,#ffb4b4,#ff7b7b)}

  .side-panel{
    width:260px;max-width:35vw;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:12px;border-radius:10px;height:var(--board-h);
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
    display:flex;flex-direction:column;gap:12px;
  }

  .preview{
    height:120px;background:rgba(255,255,255,0.02);border-radius:8px;padding:8px;display:flex;align-items:center;justify-content:center;
  }
  .preview-grid{
    display:grid;grid-template-columns:repeat(4, calc(var(--tile-size) - 6px));grid-template-rows:repeat(4, calc(var(--tile-size) - 6px));gap:6px;
  }
  .small-cell{width:calc(var(--tile-size) - 6px);height:calc(var(--tile-size) - 6px);border-radius:6px;background:transparent;border:1px dashed rgba(255,255,255,0.02)}
  .muted{color:var(--muted);font-size:13px}

  /* mobile controls overlay */
  .touch-controls{
    display:none;
    position:fixed;left:0;right:0;bottom:18px;padding:0 16px;pointer-events:none;
    justify-content:space-between;max-width:1000px;margin:0 auto;
  }
  .touch-row{display:flex;gap:12px;pointer-events:auto;}
  .touch-btn{
    width:56px;height:56px;border-radius:12px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;
    border:1px solid rgba(255,255,255,0.04);font-weight:700;font-size:18px;color:inherit;user-select:none;
    touch-action: manipulation;
  }

  .hud{
    display:flex;align-items:center;gap:8px;justify-content:space-between;
  }

  .footer{
    margin-top:auto;font-size:12px;color:var(--muted);display:flex;align-items:center;justify-content:space-between;
  }

  /* responsive */
  @media (max-width:880px){
    .container{grid-template-columns: 1fr;gap:12px;padding-bottom:90px}
    .sidebar{order:2;width:100%}
    .game-area{justify-content:center}
    .side-panel{height:auto;width:100%}
    .touch-controls{display:flex}
  }

  /* subtle animations on clear */
  .clear-line{
    animation: clearFlash .45s ease forwards;
  }
  @keyframes clearFlash{
    0%{opacity:1;transform:translateY(0)}
    50%{opacity:0.3;transform:translateY(-8px)}
    100%{opacity:0;transform:translateY(20px)}
  }
</style>
</head>
<body>
  <div class="container" role="application" aria-label="Tetris game">
    <aside class="sidebar" aria-hidden="false">
      <div class="brand">
        <div class="logo">T</div>
        <div>
          <h1>Retro Modern Tetris</h1>
          <p class="sub">Classic Tetris with responsive controls — keyboard & touch</p>
        </div>
      </div>

      <div class="stats" aria-hidden="false">
        <div class="stat">
          <div class="value" id="score">0</div>
          <div class="label">Score</div>
        </div>
        <div class="stat">
          <div class="value" id="level">1</div>
          <div class="label">Level</div>
        </div>
        <div class="stat">
          <div class="value" id="lines">0</div>
          <div class="label">Lines</div>
        </div>
        <div class="stat">
          <div class="value" id="hold">—</div>
          <div class="label">Hold</div>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="btn-start">Start</button>
        <button class="btn" id="btn-pause">Pause</button>
        <button class="btn" id="btn-sound">Sound: On</button>
        <button class="btn" id="btn-reset">Reset</button>
      </div>

      <div class="meta">
        <div class="muted">Controls</div>
        <div class="muted">← → move • ↑ rotate • ↓ soft drop • Space hard drop</div>
      </div>

      <div style="height:6px;"></div>

      <div class="footer">
        <div class="muted">Made with ❤️ — Paste into a single HTML file</div>
        <div class="muted">v1.0</div>
      </div>
    </aside>

    <main class="game-area" aria-live="polite">
      <div class="board-wrap" role="region" aria-label="Game board">
        <div id="board" class="board" tabindex="0"></div>
      </div>

      <aside class="side-panel" aria-hidden="false">
        <div>
          <div class="muted">Next</div>
          <div class="preview" id="preview">
            <div class="preview-grid" id="preview-grid"></div>
          </div>
        </div>

        <div>
          <div class="muted">Controls (touch)</div>
          <div style="display:flex;gap:8px;margin-top:8px;">
            <div class="muted" style="font-size:13px;">Left • Right • Rotate • Drop</div>
          </div>
        </div>

        <div style="display:flex;gap:8px;margin-top:8px;">
          <button class="btn" id="btn-fullscreen">Fullscreen</button>
          <button class="btn" id="btn-sound-toggle">Toggle SFX</button>
        </div>
      </aside>
    </main>
  </div>

  <!-- Mobile touch controls (visible on small screens) -->
  <div class="touch-controls" id="touch-controls" aria-hidden="true">
    <div class="touch-row" style="flex:1;justify-content:flex-start;">
      <div class="touch-btn" id="touch-left">◀</div>
      <div class="touch-btn" id="touch-rotate">⟳</div>
      <div class="touch-btn" id="touch-right">▶</div>
    </div>
    <div class="touch-row" style="flex:1;justify-content:flex-end;">
      <div class="touch-btn" id="touch-down">↓</div>
      <div class="touch-btn" id="touch-drop">⤓</div>
    </div>
  </div>

<script>
/*
  Modern Retro Tetris
  Single-file implementation with:
  - 10x20 playfield
  - Tetromino definitions (rotations)
  - Scoring, levels, speed increase
  - Next piece preview
  - Keyboard + touch controls
  - WebAudio SFX (toggleable)
  - Clean, readable code with comments
*/

/* -------------------------
   Game constants & helpers
--------------------------*/
const COLS = 10;
const ROWS = 20;
const TILE_GAP = 4; // used in CSS, accounted for in rendering implicitly
const POINTS = {0:0, 1:100, 2:300, 3:500, 4:800}; // classic-ish
const LINES_PER_LEVEL = 10;
const PREVIEW_SIZE = 4;

const COLORS = {
  I: 't-I', J: 't-J', L: 't-L', O: 't-O', S: 't-S', T: 't-T', Z: 't-Z'
};

// Tetromino shapes: arrays of rotation matrices (4x4)
const TETROMINOES = {
  I: [
    [[0,0,0,0],
     [1,1,1,1],
     [0,0,0,0],
     [0,0,0,0]],
    [[0,0,1,0],
     [0,0,1,0],
     [0,0,1,0],
     [0,0,1,0]]
  ],
  J: [
    [[1,0,0],
     [1,1,1],
     [0,0,0]],
    [[0,1,1],
     [0,1,0],
     [0,1,0]],
    [[0,0,0],
     [1,1,1],
     [0,0,1]],
    [[0,1,0],
     [0,1,0],
     [1,1,0]]
  ],
  L: [
    [[0,0,1],
     [1,1,1],
     [0,0,0]],
    [[0,1,0],
     [0,1,0],
     [0,1,1]],
    [[0,0,0],
     [1,1,1],
     [1,0,0]],
    [[1,1,0],
     [0,1,0],
     [0,1,0]]
  ],
  O: [
    [[1,1],
     [1,1]]
  ],
  S: [
    [[0,1,1],
     [1,1,0],
     [0,0,0]],
    [[0,1,0],
     [0,1,1],
     [0,0,1]]
  ],
  T: [
    [[0,1,0],
     [1,1,1],
     [0,0,0]],
    [[0,1,0],
     [0,1,1],
     [0,1,0]],
    [[0,0,0],
     [1,1,1],
     [0,1,0]],
    [[0,1,0],
     [1,1,0],
     [0,1,0]]
  ],
  Z: [
    [[1,1,0],
     [0,1,1],
     [0,0,0]],
    [[0,0,1],
     [0,1,1],
     [0,1,0]]
  ]
};

const ALL_PIECES = Object.keys(TETROMINOES);

/* -------------------------
   Game state
--------------------------*/
let playfield; // ROWS x COLS array of null or {type}
let current = null; // {type, rotation, x, y}
let nextPiece = null;
let holdPiece = null;
let canHold = true;
let dropInterval = 1000; // ms
let dropTimer = null;
let playing = false;
let paused = false;

let score = 0;
let lines = 0;
let level = 1;

let sfxEnabled = true;

/* DOM */
const boardEl = document.getElementById('board');
const previewGrid = document.getElementById('preview-grid');
const elScore = document.getElementById('score');
const elLevel = document.getElementById('level');
const elLines = document.getElementById('lines');
const elHold = document.getElementById('hold');
const btnStart = document.getElementById('btn-start');
const btnPause = document.getElementById('btn-pause');
const btnReset = document.getElementById('btn-reset');
const btnSound = document.getElementById('btn-sound');
const btnSoundToggle = document.getElementById('btn-sound-toggle');
const btnFullscreen = document.getElementById('btn-fullscreen');

/* Audio (WebAudio) */
let audioCtx = null;
function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}
function sfx(type='blip', freq=200, dur=0.06){
  if(!sfxEnabled) return;
  initAudio();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = (type==='pop') ? 'triangle' : 'sine';
  o.frequency.value = freq;
  g.gain.value = 0.04;
  o.connect(g);
  g.connect(audioCtx.destination);
  o.start();
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
  o.stop(audioCtx.currentTime + dur + 0.01);
}

/* -------------------------
   Initialize playfield & rendering
--------------------------*/
function createPlayfield(){
  const a = [];
  for(let y=0;y<ROWS;y++){
    a.push(new Array(COLS).fill(null));
  }
  return a;
}

function createBoardCells(){
  boardEl.innerHTML = '';
  for(let i=0;i<ROWS*COLS;i++){
    const d = document.createElement('div');
    d.className = 'cell';
    boardEl.appendChild(d);
  }
}
createBoardCells();

function cellIndex(x,y){ return y*COLS + x; }

function render(){
  // render playfield to board cells
  const cells = boardEl.children;
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const idx = cellIndex(x,y);
      const el = cells[idx];
      const cell = playfield[y][x];
      if(cell){
        el.className = 'cell filled ' + COLORS[cell];
        el.setAttribute('aria-label', cell + ' block');
      } else {
        el.className = 'cell';
        el.removeAttribute('aria-label');
      }
    }
  }

  // draw current piece
  if(current){
    const shape = getMatrix(current.type, current.rotation);
    for(let r=0;r<shape.length;r++){
      for(let c=0;c<shape[r].length;c++){
        if(shape[r][c]){
          const x = current.x + c;
          const y = current.y + r;
          if(y>=0 && y<ROWS && x>=0 && x<COLS){
            const idx = cellIndex(x,y);
            const el = boardEl.children[idx];
            el.className = 'cell filled ' + COLORS[current.type];
            // subtle highlight for active piece
            el.style.transform = 'translateY(-2px)';
          }
        }
      }
    }
  }

  // draw ghost piece (simple: show translucent where it would land)
  const ghostY = getDropY();
  if(current){
    const shape = getMatrix(current.type, current.rotation);
    for(let r=0;r<shape.length;r++){
      for(let c=0;c<shape[r].length;c++){
        if(shape[r][c]){
          const x = current.x + c;
          const y = ghostY + r;
          if(y>=0 && y<ROWS && x>=0 && x<COLS){
            const idx = cellIndex(x,y);
            const el = boardEl.children[idx];
            // if cell already filled show original; else add faint border
            if(!playfield[y][x]){
              el.style.boxShadow = 'inset 0 0 0 2px rgba(255,255,255,0.03)';
              el.style.opacity = '0.25';
            }
          }
        }
      }
    }
  }

  // update HUD
  elScore.textContent = score;
  elLevel.textContent = level;
  elLines.textContent = lines;
  elHold.textContent = holdPiece ? holdPiece : '—';
}

/* -------------------------
   Tetromino helpers
--------------------------*/
function getMatrix(type, rot=0){
  const variants = TETROMINOES[type];
  if(!variants) return [[1]];
  // Many pieces have 2 or 4 rotations; handle modulo
  return variants[rot % variants.length];
}

function spawnPiece(type=null){
  const t = type || randomPiece();
  const matrix = getMatrix(t,0);
  // center horizontally
  const w = matrix[0].length;
  const x = Math.floor((COLS - w) / 2);
  const y = -matrix.length; // spawn above board
  return {type: t, rotation: 0, x, y};
}

function randomPiece(){
  // 7-bag would be better; implement simple bag for fairness
  if(!randomPiece.bag || randomPiece.bag.length===0){
    randomPiece.bag = shuffle(ALL_PIECES.slice());
  }
  return randomPiece.bag.pop();
}
function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}

/* -------------------------
   Collision & movement
--------------------------*/
function collide(piece, px = piece.x, py = piece.y, prot = piece.rotation){
  const m = getMatrix(piece.type, prot);
  for(let r=0;r<m.length;r++){
    for(let c=0;c<m[r].length;c++){
      if(m[r][c]){
        const x = px + c;
        const y = py + r;
        if(x<0 || x>=COLS || y>=ROWS){
          return true;
        }
        if(y>=0 && playfield[y][x]){
          return true;
        }
      }
    }
  }
  return false;
}

function move(dx, dy){
  if(!current || paused) return;
  const nx = current.x + dx;
  const ny = current.y + dy;
  if(!collide(current, nx, ny, current.rotation)){
    current.x = nx; current.y = ny;
    sfx('blip', 220, 0.03);
    render();
    return true;
  }
  return false;
}

function rotate(dir=1){
  if(!current || paused) return;
  const newRot = (current.rotation + dir + 100) % 1000; // will mod by shape length in getMatrix
  // basic wall kick attempts: 0, ±1, ±2
  const kicks = [0, -1, 1, -2, 2];
  for(const k of kicks){
    if(!collide(current, current.x + k, current.y, newRot)){
      current.rotation = newRot;
      current.x += k;
      sfx('pop', 320, 0.06);
      render();
      return true;
    }
  }
  // failed rotate
  sfx('blip', 100, 0.02);
  return false;
}

function hardDrop(){
  if(!current || paused) return;
  const y = getDropY();
  const dist = y - current.y;
  current.y = y;
  lockPiece();
  score += dist * 2; // bonus
  sfx('blip', 420, 0.03);
  render();
}

/* find the drop Y of the current piece */
function getDropY(){
  if(!current) return 0;
  let y = current.y;
  while(!collide(current, current.x, y+1, current.rotation)) y++;
  return y;
}

/* -------------------------
   Locking and line clear
--------------------------*/
function lockPiece(){
  const shape = getMatrix(current.type, current.rotation);
  for(let r=0;r<shape.length;r++){
    for(let c=0;c<shape[r].length;c++){
      if(shape[r][c]){
        const x = current.x + c;
        const y = current.y + r;
        if(y<0){
          // game over
          gameOver();
          return;
        }
        playfield[y][x] = current.type;
      }
    }
  }

  // check lines
  const cleared = [];
  for(let y=0;y<ROWS;y++){
    if(playfield[y].every(cell => cell !== null)){
      cleared.push(y);
    }
  }

  if(cleared.length){
    // animate clear: mark then remove
    for(const y of cleared){
      for(let x=0;x<COLS;x++){
        const idx = cellIndex(x,y);
        const el = boardEl.children[idx];
        el.classList.add('clear-line');
      }
    }
    sfx('pop', 220 + cleared.length*40, 0.18);
    // remove lines after short delay for animation
    setTimeout(()=> {
      for(const y of cleared){
        playfield.splice(y,1);
        playfield.unshift(new Array(COLS).fill(null));
      }
      // update score
      score += POINTS[cleared.length] * level;
      lines += cleared.length;
      // level up
      const newLevel = Math.floor(lines / LINES_PER_LEVEL) + 1;
      if(newLevel !== level){
        level = newLevel;
        updateDropInterval();
        sfx('blip', 700, 0.12);
      }
      render();
    }, 120);
  }

  // spawn next
  current = nextPiece ? spawnPiece(nextPiece) : spawnPiece();
  nextPiece = randomPiece();
  canHold = true;
  render();
}

/* -------------------------
   Game lifecycle
--------------------------*/
function startGame(){
  playfield = createPlayfield();
  createBoardCells();
  current = spawnPiece();
  nextPiece = randomPiece();
  holdPiece = null;
  canHold = true;
  score = 0; lines = 0; level = 1;
  updateDropInterval();
  playing = true; paused = false;
  render();
  stopDropTimer();
  startDropTimer();
  sfx('blip', 280, 0.06);
}

function pauseGame(){
  if(!playing) return;
  paused = !paused;
  if(paused) stopDropTimer();
  else startDropTimer();
  btnPause.textContent = paused ? 'Resume' : 'Pause';
  sfx('blip', 220, 0.04);
}

function resetGame(){
  playing = false;
  paused = false;
  stopDropTimer();
  playfield = createPlayfield();
  createBoardCells();
  current = null;
  nextPiece = null;
  holdPiece = null;
  score = 0; lines = 0; level = 1;
  render();
}

function gameOver(){
  playing = false;
  stopDropTimer();
  sfx('pop', 120, 0.24);
  alert('Game Over — Score: ' + score);
  resetGame();
}

/* -------------------------
   Drop timer and gravity
--------------------------*/
function updateDropInterval(){
  // classic exponential: base speed decreases with level
  // We use a simple mapping that speeds up with higher levels
  const base = 1000;
  // clamp level effect
  dropInterval = Math.max(80, Math.round(base * Math.pow(0.9, level-1)));
}

function startDropTimer(){
  stopDropTimer();
  dropTimer = setInterval(()=> {
    if(!current || paused) return;
    // try move down; if collide, lock
    if(!move(0,1)){
      lockPiece();
    }
  }, dropInterval);
}

function stopDropTimer(){
  if(dropTimer) {clearInterval(dropTimer); dropTimer = null;}
}

/* -------------------------
   Hold logic (basic)
--------------------------*/
function holdCurrent(){
  if(!current || !canHold) return;
  if(!holdPiece){
    holdPiece = current.type;
    current = spawnPiece(nextPiece || randomPiece());
    nextPiece = randomPiece();
  } else {
    const tmp = holdPiece;
    holdPiece = current.type;
    current = spawnPiece(tmp);
  }
  canHold = false;
  sfx('blip', 320, 0.05);
  render();
}

/* -------------------------
   Input handling (keyboard + touch)
--------------------------*/
window.addEventListener('keydown', (e)=>{
  if(!playing) return;
  if(e.key === 'ArrowLeft'){ e.preventDefault(); move(-1,0); }
  else if(e.key === 'ArrowRight'){ e.preventDefault(); move(1,0); }
  else if(e.key === 'ArrowDown'){ e.preventDefault(); move(0,1); score += 1; } // soft drop reward
  else if(e.key === 'ArrowUp'){ e.preventDefault(); rotate(1); }
  else if(e.code === 'Space'){ e.preventDefault(); hardDrop(); }
  else if(e.key.toLowerCase() === 'c'){ e.preventDefault(); holdCurrent(); }
  else if(e.key.toLowerCase() === 'p'){ e.preventDefault(); pauseGame(); }
});

btnStart.addEventListener('click', ()=> { startGame(); });
btnPause.addEventListener('click', ()=> { pauseGame(); });
btnReset.addEventListener('click', ()=> { resetGame(); });
btnSound.addEventListener('click', ()=> {
  sfxEnabled = !sfxEnabled;
  btnSound.textContent = 'Sound: ' + (sfxEnabled ? 'On' : 'Off');
});
btnSoundToggle.addEventListener('click', ()=> {
  sfxEnabled = !sfxEnabled;
  btnSound.textContent = 'Sound: ' + (sfxEnabled ? 'On' : 'Off');
  btnSoundToggle.textContent = sfxEnabled ? 'SFX: On' : 'SFX: Off';
});
btnFullscreen.addEventListener('click', ()=> {
  if(!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch(()=>{ /* ignore */});
  } else {
    document.exitFullscreen();
  }
});

/* Mobile touch buttons */
function makeTouch(id, handler, repeat=false){
  const el = document.getElementById(id);
  let timer = null;
  const start = (e)=>{
    e.preventDefault();
    handler();
    if(repeat){
      timer = setInterval(handler, 150);
    }
  };
  const end = ()=> { if(timer) clearInterval(timer); timer=null; };
  el.addEventListener('touchstart', start);
  el.addEventListener('mousedown', start);
  el.addEventListener('touchend', end);
  el.addEventListener('mouseup', end);
  el.addEventListener('mouseleave', end);
}
makeTouch('touch-left', ()=> move(-1,0), true);
makeTouch('touch-right', ()=> move(1,0), true);
makeTouch('touch-down', ()=> { move(0,1); score+=1; }, true);
makeTouch('touch-rotate', ()=> rotate(1), false);
makeTouch('touch-drop', ()=> hardDrop(), false);

/* -------------------------
   Preview rendering
--------------------------*/
function renderPreview(){
  previewGrid.innerHTML = '';
  // 4x4 grid
  for(let y=0;y<PREVIEW_SIZE;y++){
    for(let x=0;x<PREVIEW_SIZE;x++){
      const d = document.createElement('div');
      d.className = 'small-cell';
      previewGrid.appendChild(d);
    }
  }
  if(!nextPiece) return;
  const shape = getMatrix(nextPiece, 0);
  // center within 4x4 grid
  const offsetX = Math.floor((PREVIEW_SIZE - shape[0].length)/2);
  const offsetY = Math.floor((PREVIEW_SIZE - shape.length)/2);
  for(let r=0;r<shape.length;r++){
    for(let c=0;c<shape[r].length;c++){
      if(shape[r][c]){
        const idx = (offsetY + r) * PREVIEW_SIZE + (offsetX + c);
        const el = previewGrid.children[idx];
        if(el) el.className = 'small-cell ' + COLORS[nextPiece];
      }
    }
  }
}

/* -------------------------
   Main loop: render periodically & manage animations
--------------------------*/
function tick(){
  render();
  renderPreview();
  // reset transient styles (ghost shadows) each tick
  const cells = [...boardEl.children];
  cells.forEach(el => {
    el.style.boxShadow = '';
    el.style.opacity = '';
    el.style.transform = '';
    el.classList.remove('clear-line');
  });
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* -------------------------
   Utility
--------------------------*/
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

/* -------------------------
   Initialization
--------------------------*/
resetGame(); // create empty board

// auto-start on first interaction for convenience
document.addEventListener('pointerdown', function once(){
  initAudio();
  document.removeEventListener('pointerdown', once);
}, {once:true});

// make board focusable so arrow keys work on some browsers without focusing elsewhere
boardEl.addEventListener('click', ()=> boardEl.focus());
boardEl.setAttribute('tabindex','0');

/* keep preview updated when nextPiece changes */
const origRandom = randomPiece;
(function watchPreview(){
  const orig = randomPiece;
  randomPiece = function(){
    const p = orig();
    // store nextPiece if it's not yet set
    return p;
  };
})();

setInterval(()=>{ renderPreview(); }, 500);

/* expose for debugging (optional) */
window._tetris = {
  start: startGame,
  pause: pauseGame,
  reset: resetGame,
  setSound: (b)=>{ sfxEnabled = !!b; btnSound.textContent = 'Sound: ' + (sfxEnabled ? 'On':'Off') }
};

</script>
</body>

</html>
